## `Xshell 7与WinScp`连接`Linux`

## 基于`Clash for Windows In Linux`配置``Linux VPN``外网访问

- 使用`mkdir /home/用户名/下载/Clash`创建`Clash`安装目录

- [下载Clash.for.Windows-0.19.23-X64-linux.tar.gz](https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.19.23/Clash.for.Windows-0.19.23-arm64-linux.tar.gz)

- 使用`WinScp`将下载的文件存入`home/用户名/下载/Clash`目录下

- 在`Clash`目录下使用` tar -zxvf 文件名`解压我们下载的文件

- 在对应目录下运行`cfw`文件(或在终端的对应目录下使用`./cfw`运行)

- ```shell
  #1
  mkdir /home/tangling/下载/Clash
  #2
  cd /home/tangling/下载/Clash
  #3
  tar -zxvf Clash.for.Windows-0.19.23-X64-linux.tar.gz
  ls
  #4
  mv Clash.for.Windows-0.19.23-X64-linux Clash-Linux
  #5
  cd Clash-Linux
  #6
  sudo ./cfw
  ```

  

- 通过飞机场的``URL``获取配置信息并应用配置

  <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220708172418880.png" alt="image-20220708172418880" style="zoom: 50%;" />

- 点击`Clash`软件的常规中的按钮

<img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220708171029424.png" alt="image-20220708171029424" style="zoom:50%;" />

- 复制内容

<img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220708171113100.png" alt="image-20220708171113100" style="zoom: 67%;" />

- 打开终端并粘贴我们复制的内容运行

- 当我们不需要使用时

  ```shell
  unset https_proxy,http_proxy,all_proxy
  ```

## `Linux`网络配置

### `Linux`静态`IP`配置

> **注意事项**
>
> - 我们配置的静态`IP`地址必须在我们`VMware`虚拟机的`Vmnet8`的子网范围内,如果超出范围,则可能造成网络连接失败

- 进入`/etc/netplan`文件夹

- 修改`.yaml`配置文件

  ```yaml
  network:
  	ethernets:
  		ens33:
  			dhcp4: no
  			dhcp6: no
  			addresses:
  				- 192.168.80.128
  			routes:
  				- to: default
  				  via: 192.168.80.2
  			nameservers
  				addresses:
  					- 192.168.80.2
  					- 114.114.114.114
  					- 8.8.8.8
  	version: 2
  	render: NetworkManager
  ```

- 使用`sudo netplan apply`应用我们的修改

### `Linux`用户``hosts``配置

> 这个配置可以让我们能够在`Linux`系统下通过一个特定的名称来访问一个`IPV4`地址所指向的主机

- 进入`/etc`目录下

- `/etc/hosts`文件中保存的就是各个`IP`地址向我们的自定义名称的映射关系

  <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220711104919969.png" alt="image-20220711104919969" style="zoom:67%;" />

- 若我们需要通过`sudo vim /etc/hosts`向`hosts`文件中添加一条`192.168.80.129`到名称`MaTingRong`的映射,则只需要在我们文件中写入改映射关系即可

  <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220711105027454.png" alt="image-20220711105027454" style="zoom:67%;" />

### `Linux`防火墙关闭

> 在`Ubuntu 22.04`版本中,防火墙所对应的系统服务为`ufw.service`因此我们只需要使用`systemctl`命令关闭该服务以及取消其开机自启动权限即可

- `systemctl stop ufw`
- `systemctl disable ufw`

## `Linux`文件系统

### 前置条件

> **在`Linux`中有一个重要的概念`一切皆文件`**,即`Linux`中一切东西,都有一个文件与其相互对应.
>
> - 给系统**接入一个键盘**,那么文件系统中就会维护一个对应于这个键盘的文件
>
> - 给系统**接入一个鼠标**,那么文件系统中就会维护一个对应于这个鼠标的文件.
>
> 由于`一切皆文件`而`Linux`又对于文件的权限有着严格的限制,因此`Linux`中借助对于文件的权限的管理,使得我们`Linux`系统可以对设备进行权限管理

### `Linux`文件系统体系架构

<img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709140215561.png" alt="image-20220709140215561" style="zoom: 80%;" />

- `Application`
- `System Call Interface`
- `Virtual File System`:同`GBDL`,文件系统也是多种多样的,他们提供的接口也不尽相同,因此我们的`Virtual FIle System`也通过抽象`API`的方式统一了文件系统`API`
- `Ext3|Ext4|Btrfs`:**文件系统**,在下面我们通过`IO API`获取到了硬盘上存储的信息,那么我们就需要通过一定的方式将这些数据整合起来,以一种利于用户读取的格式,并提供获取这些整合数据的`API`
- `General Block Device Layer`:**不同的驱动给操作系统提供的`IO API`都是不会完全相同的**,而这一层的作用就是将针**对不同设备的`IO API`进行统一的封装**,对于不同设备上的同一操作的不同`API`**设置一个统一的抽象的`API`接口**.而具体调用哪一个具体`API`则由我们当前层决定.**通过这一层,我们统一了硬盘的`IO API`**
- `Device Driver`:硬盘驱动,用于作为操作系统与物理设备的中间程序使得操作系统能够正常使用物理设备.
  - 由于市面上有许多种类的硬盘,如`SATA|PATA|AHCI|M.2`等,不同类型的硬盘往往需要不同的驱动程序来进行使用.因此这一就是指的我们的硬盘驱动.
  - 这些驱动的驱动文件存储在`/drivers/ata`目录下
- `Physical Disk`:物理磁盘,其上可以存储数据,但需要一定的程序与设备对其内容进行读取

## `Linux`挂载

> - **背景**:我们知道`Linux`秉持`一切皆文件`的原则,但是我们的文件不能杂乱的安置(这会导致我们每当需要访问某个文件都需要扫描整个存储设备),我们必须有一个良好的数据结构将各个文件的物理地址组织起来才能够让我们实现对其的快速访问.
>
> - **实现方式**:`Linux`系统会**维护一个树**,这个树将系统中各个文件的信息结构化的组织起来,当我们需要访问指定文件时,只需要使用树结构结点访问方法即可轻松地获取到树结构中存储的目标文件的存储位置信息等.
>
> - **树结构剖析**:通常情况下`Linux`维护的树是以`/`目录为根节点,然后以`bin,usr,opt`等目录为二级目录,然后一级一级向深处衍生,所有这些二级目录下的所有``文件,目录``的存储信息都全部会被递归地存储在我们的树上各自作为一个节点
>
>   <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709151326569.png" alt="image-20220709151326569" style="zoom:67%;" />
>
> - **什么是挂载**:**挂载就是将文件的信息存储到`Linux`文件树上**.我们知道如果我们需要访问`Linux`系统中的任何文件,我们就需要访问`Linux`文件树,来获取该文件的存储位置等信息,如果我们将文件挂载到`Linux`文件树上,我们是无法通过常规的方法访问该文件的.
>
> - **为什么设备使用前需要挂载**:在`Linux`中秉持`一切皆文件`的思想,**外接设备接入**到我们的`Linux`系统后**也会有一个其对应的文件**.而`Linux`**系统中**对于**设备的使用**都是**基于该设备对应的文件**的,而系统在外接设备接入时,虽然**会自动生成其文件**,但是有时**不会将其挂载到我们的`Linux`文件树上**,而**不挂载**就**无法访问该设备的文件**,也就意味着系统**无法使用该设备**.**因此,我们接入外接设备后要将其对应的文件挂载到我们的`Linux`文件树上**
>
> - **`Linux`的基本设备文件存储在哪里?**:在`Linux`中`CPU`等设备对应的文件都是保存在`/dev`目录下的

## `Linux`文件系统与挂载

> - `Linux`的每一个文件系统都会维护其各自的文件树,因此我们将文件挂载到`Linux`文件树的操作,需要我们指定需要挂载到哪个文件系统上.(当然我们可以不指定,因为系统会自动根据状况智能选择文件系统进行挂载)
> - 

## `Linux`编辑器`VIM`

### 一般模式

| 关键字             | 功能                               |
| ------------------ | ---------------------------------- |
| `dd`               | 删除当前光标所在行                 |
| `d数字d`           | 删除当前光标所在行及其下方n行      |
| `yy`               | 复制当前行                         |
| `y数字y`           | 复制当前行及其下方n行              |
| `p`                | 将复制的内容粘贴到光标所在行的下方 |
| `u`                | 撤销上一步操作                     |
| `X`                | 删除当前光标所在的字符的前一个字符 |
| `x`                | 删除当前光标所在的字符             |
| `dw`               | 删除一个字母或汉字                 |
| `yw`               | 复制一个字母或汉字                 |
| `SHIFT + 4`        | 光标移动到行首                     |
| `SHIFT + 6`        | 光标移动到行尾                     |
| `数字 + SHIFT + g` | 光标移动到指定行                   |
| `SHIFT + g`        | 光标移动到最后一行                 |

### 模式切换

> **总共有如下三个模式**
>
> - **一般模式**
> - **插入模式**
> - **指令模式**
>
> **注意**:指令模式与插入模式之间无法转换

<img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220708145737927.png" alt="image-20220708145737927" style="zoom: 60%;" />

### 一般模式``->``插入模式

| 选项 | 功能                   |
| ---- | ---------------------- |
| `i`  | 当前光标前             |
| `a`  | 当前光标后             |
| `o`  | 当前光标所在行的下一行 |
| `I`  | 光标所在行的行首       |
| `A`  | 光标所在行的行尾       |
| `O`  | 光标所在行的上一行     |

### 插入模式`->`一般模式

> `ESC`

### 一般模式`->`指令模式

![image-20220709152828144](F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709152828144.png)

## 基于`Netplan`的``Linux``网络配置

> <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image_70.png" alt="image_70" style="zoom:67%;" />
>
> - `ens33`:网络接口名称
> - `dhcp4`:``yes|no``,是否对`IPV4`地址进行`DHCP`动态分配
> - `dhcp6`:`yes|no`,是否对`IPV6`地址进行`DHCP`动态分配
> - `addresses`:指定静态`IPV4`地址
> - `routes`:指定网关的`IPV4`地址
> - `nameserver`:指定`DNS`服务器的`IPV4`地址
> - `renderer`:指定网络管理应用
>   - `networkd`:非桌面版(即命令行版)网络管理应用,该管理应用下不会出现网络连接图标
>     - ![image-20220709154407906](F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709154407906.png)
>   - `NetworkManager`:桌面版(即可视化版)网络管理应用,该管理应用下会出现网络连接图标
>     - ![image-20220709154340792](F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709154340792.png)
> - `version`:

## `Linux`系统管理

### `systemctl`指令

> 作用:
>
> - 控制系统服务的**运行,停止,重启**
> - **服务运行状态获取**
> - **开机自启动权限**
> - **查看设置系统运行等级**

- **基本语法**

  ```shell
  #启动,关闭,重启指定服务
  #获取指定服务的运行状态
  systemctl start|stop|restart|status 服务名
  ```

- **查看所有服务的开机启动状态(是否自动开机等)**

  ```shell
  systemctl list-unit-list
  ```

- **查看当前主机所有的服务**

  ```shell
  cd /usr/lib/systemd/system
  ```

- **关闭指定服务的开机自启动**

  ```shell
  systemctl disable 服务名
  ```

- **开启指定服务的开机自启动**

  ```shell
  systemctl enable 服务名
  ```

- **查看当前系统运行级别**

  ```shell
  systemctl get-default
  ```

- **修改系统默认运行级别**

  ```shell
  systemctl set-default [multi-user|graphical].target
  #例
  systemctl set-default multi-user.target
  systemctl set-default graphical.target
  ```

## `Linux`关机与重启命令

> `Linux`系统中为了提高磁盘的读写效率,对磁盘采取了 “**预读迟写**”操作方式.当用户保存文件时,``Linux`` 核心**并不一定立即将保存数据写入物理磁盘中**,**而是将数据保存在缓冲区中**,等**缓冲区满**时**再写入磁盘**,这种方式可以极大的提高磁盘写入数据的效率.但是,也带来了**安全隐患**,**如果数据还未写入磁盘时**,**系统掉电**或者其他**严重问题出现**,则将导致**数据丢失**。 使用 `sync` 指令可以**立即将缓冲区的数据写入磁盘。**  

- `sync`:将内存中保存着的数据存储至磁盘中
- `halt`:关闭系统,但不断电.类似于`Windows`的睡眠
- `poweroff`:关机,断电
- `reboot`:重启

## `Linux`运行级别(``CentOS 7``)

- `multi-user.target`:多用户,命令行界面
- `graphical.target`:多用户,图形界面

## `Linux`常用`Shell`命令

### 基本命令

- **使用`man`查看指定命令的帮助文档**

  ```shell
  man ls
  ```

  <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220707214739828.png" alt="image-20220707214739828" style="zoom:67%;" />

- **使用`help`获取`Shell`的内置命令的帮助文档**

  ```shell
  help cd
  ```

- `clear`清屏

  ```shell
  clear
  ```

### 目录相关命令(增删改查)

- **使用`pwd`显示当前目录的绝对路径**

  ```shell
  pwd
  ```

- **使用`ls`列出目录的所有内容**

  ```shell
  #列出当前目录的所有内容(不包含隐藏文件)
  ls
  #列出当前目录的所有内容(包含隐藏文件)
  ls -a
  #列出当前目录的所有内容的详细信息(不包含隐藏文件)
  ls -l
  #列出当前目录的所有内容的详细信息(包含隐藏文件)
  ls -al
  #文件类型与权限 链接数 文件属主 文件属组 文件大小单位为Bytes 建立或最近修改的时间 名字
  ```

- **使用`cd`切换目录**

  | 参数          | 功能                         |
  | ------------- | ---------------------------- |
  | `cd 绝对路径` | 切换到指定绝对路径下         |
  | `cd 相对路径` | 切换到指定相对路径下         |
  | `cd /`        | 切换至根目录                 |
  | `cd -`        | 返回上次所在目录             |
  | `cd ..`       | 返回当前目录的上一级目录     |
  | `cd -P`       | 跳转到软链接对应的物理路径上 |

  - `.`:表示当前目录
  - `..`:表示当前目录的上一级目录

- **使用`mkdir`创建目录**

  ```shell
  #在指定路径下创建指定目录(要求路径指示的目录都是已经存在的)
  mkdir 路径/目录名
  #不要求路劲指示的目录都是存在的,如果不存在会自动创建
  mkdir -p 路径/目录名
  ```

- **使用`rmdir`删除空目录**

  ```shell
  #要求为目录为空
  rmdir 路径/目录名
  ```

### 文件相关命令(增删改查)

- **使用`touch`创建空文件**

  ```shell
  #要求路径指示的所有目录都存在
  touch 路径/文件名.后缀
  ```

- **使用`cp`复制文件(或文件夹)到指定目录**

  ```shell
  #复制指定文件到指定目录
  cp 路径/被复制的文件名 路径/要复制到的目录/
  #复制指定目录到指定目录
  cp -r 路径/被复制的目录/ 路径/要复制到的目录/
  
  #实例
  cp xiyou/dssz/suwukong.txt xiyou/mingjie/
  cp -r xiyou/dssz/ ./
  ```

- **使用`rm`删除指定文件(或目录)**

  ```shell
  #删除指定文件
  rm 路径/文件名
  #强制删除指定文件
  rm -f 路径/文件名
  #删除指定目录
  rm -r 路径/目录名/
  #强制删除指定目录
  rm -rf 路径/目录名/
  ```

  | 指令 | 作用                                    |
  | ---- | --------------------------------------- |
  | `-f` | 强制执行删除操作， 而不提示用于进行确认 |
  | `-r` | 递归删除目录中所有内容                  |
  | `-v` | 显示指令的详细执行过程                  |

- **使用`mv`对文件(或目录)进行重命名(或移动)**

  ```shell
  #对文件重命名
  mv 路径A/旧文件名 路径A/新文件名
  #将文件移动到指定目录下
  mv 路径A/文件名 路径B/目录名/
  #将文件移动到指定目录下并重命名
  mv 路径A/文件名 路径B/目录名/新文件名
  #对目录重命名
  mv 路径A/旧目录名 路径A/新目录名
  #将目录移动到指定目录下
  mv 路径A/目录名A 路径B/目录名B/
  #将目录移动到指定目录下并重命名
  mv 路径A/旧目录名 路径B/目录名B/新目录名
  ```

- **使用`cat`查看文件的内容**

  ```shell
  #简易版
  cat 路径/文件名
  #显示行号
  cat -n 路径/文件名
  ```

- **使用`head`查看文件内容**

  ```shell
  #查看文件前10行内容
  head 路径/文件名
  #查看文件前x行内容
  head -n x 路径/文件名
  ```

- **使用`tail`查看文件内容**

  ```shell
  #查看文件后10行内容
  tail 路径/文件名
  #查看文件后x行内容
  tail -n x 路径/文件名
  #查看文件后10行内容并监视文件的更新动作,若文件更新了哪怕一行都马上再次输出
  tail -f 路径/文件名
  ##查看文件后x行内容并监视文件的更新动作,若文件更新了哪怕一行都马上再次输出
  tail -n x -f 路径/文件名
  ```
  
- **使用`more`查看文件内容**

  ```shell
  more 路径/文件名
  ```

  | **快捷键**   | **功能**                     |
  | ------------ | ---------------------------- |
  | **Space**    | **向下翻一页**               |
  | **Enter**    | **向下翻一行**               |
  | **q**        | **退出查看**                 |
  | **CTRL + F** | **向下滚动一屏**             |
  | **CTRL + B** | **向上滚动一屏**             |
  | **=**        | **输出当前行的行号**         |
  | **:f**       | **输出文件名与当前行的行号** |

- **使用`less`查看文件内容**

  > `less`指令在显示文件内容时， 并**不是一次将整个文件加载之后才显示**， 而是**根据显示需要加载内容**， 对于**显示大型文件具有较高的效率**  

  ```shell
  less 路径/文件名
  ```

- **使用`echo`输出我们写的内容到工作台**

  ```shell
  #直接输出内容,无法使用转义字符
  echo "字符串"
  echo "Hello\tWorld"
  #支持转义字符
  echo -e "Hello\tWorld"
  ```

- **使用`>`将命令的输出覆盖写入指定文件,`>>`将命令的输出追加写入指定文件**

  ```shell
  #标准格式
  命令 > 路径/文件名
  命令 >> 路径/文件名
  
  #案例
  #将ls命令的输出覆盖写入test.txt文件
  ls > ./test.txt
  #将ls命令的输出追加写入test.txt文件
  ls >> ./test.txt
  #将cat命令的输出覆盖写入到test.txt文件
  cat 路径/文件名 >./test.txt
  #将"Hello	World"追加写入test.txt文件
  echo -e "Hello\tWorld" >> ./test.txt
  ```

- **使用`ln`创建文件或目录软链接**

  > 软链接称为符号链接,类似于windows里的快捷方式.

  - **创建软链接**

    ```shell
    ln -s [路径/目录名 或 路径/文件名] 路径/软链接名
    ```

  - **删除软链接**

    ```shell
    #删除软链接
    rm -rf 路径/软链接名
    #删除软连接指定目录下的所有内容
    rm -rf 路径/软链接名/
    ```

  - **跳转到软连接对应的物理路径**

    ```shell
    cd -P 路径/软链接名
    ```

### 命令行相关

- **使用`history`查看所有历史命令**

  ```shell
  history
  ```

### 时间日期相关

- **使用`data`显示时间**

  | 参数                | 功能                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | ``-d<时间字符串>``  | 显示我们给出的时间字符串表示的时间<br />**注意:**改时间字符串中的**年月日**之间应以`/`或`-`分隔,**时分秒**之间以`:`分隔 |
  | `-s<日期时间>`      | 设置我们系统的日期时间为指定值                               |
  | `"+<时间日期格式>"` | 以指定时间日期格式显示我们的时间                             |

  - **时间日期格式**

    | 格式 | 功能     |
    | ---- | -------- |
    | `%Y` | 匹配年份 |
    | `%m` | 匹配月份 |
    | `%d` | 匹配天   |
    | `%H` | 匹配小时 |
    | `%M` | 匹配分钟 |
    | `%S` | 匹配秒   |

  - **示例**

    ```shell
    #-d参数
    date -d "2019/10/5 8:52:13"
    date -d "2019-10-5 8:52:13"
    #"+时间日期格式"参数
    date "+%Y-%m-%d %H:%M:%S"
    date -d "2019/10/5 8:52:13" "+%Y-%m-%d %H:%M:%S"
    
    date "+%S:%M:%H %d-%m-%Y"
    date "+%S-%M-%H %d:%m:%Y"
    date "+%S*%M(%H\\%d?%m?%Y"
    ```

- **使用`cal/ncal`查看日历**

  ```shell
  ncal
  cal
  ```

### 用户管理相关

- **使用`useradd`添加用户**

  ```shell
  #添加新用户
  useradd 用户名
  #添加新用户,并将该用户添加到指定组
  useradd -g 用户组名 用户名
  ```

- **使用`passwd`设置指定用户的密码**

  ```shell
  passwd 用户名
  ```

- **使用`id`查看指定用户是否存在**

  ```shell
  id 用户名
  ```

- **使用`su`切换用户**

  ```shell
  su 用户名
  ```

- **使用`userdel`删除指定用户**

  ```shell
  #只删除用户,不删除用户的主目录
  #如现在tangling这个账号的主目录为/home/tangling
  userdel 用户名
  #删除用户于其主目录(即删除/home/tangling这个目录)
  userdel -r 用户名
  ```

- **使用`usermod`修改指定用户的用户组归属**

  > `usermod`还有其他很多功能,这只是最常用的一个

  ```shell
  usermod -g 用户组名 用户名
  ```

- **使用`who`查看当前登陆的用户的信息**

  ```shell
  #输出当前用户名称以及登陆时间等信息
  who
  
  #输出当前用户名
  whoami
  ```

- **使用`sudo`让命令以`root`权限运行**

  ```shell
  sudo 要使用的命令
  ```

### 用户组相关

> - 在`Linux`中每一个用户归属于一个用户组
> - 如果创建用户时不指定用户所属的用户组,那么系统会自动创建一个与用户名同名的用户组.改用户就会给属于这个用户组
> - 同一用户组的用户可以对权限进行统一管理
> - `root`用户属于`root`组中

- **使用`groupadd`添加用户组**

  ```shell
  groupadd 用户组名
  ```

- **使用`groupdel`删除用户组**

  ```shell
  groupdel 用户组名
  ```

- **使用`groupmod`修改用户组的名称**

  > `groupmod`还有其他很多功能,这只是最常用的一个

  ```shell
  groupmod -n 新用户组名 旧用户组名
  ```

- **使用`cat /etc/group`查看当前所有的用户组**

### 文件权限相关

> - `Linux`系统属于典型的多用户系统,因此每个文件都要进行权限管理,如有些文件限制只有`root`用户可以读写,以保证系统安全
> - `Linux`系统的每个文件都有`10个字符`来定义其权限,这十个字符的意义如下
>   - <img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220708210716767.png" alt="image-20220708210716767" style="zoom: 67%;" />
>   - 第`0`位表示**文件的类型**,有如下选择
>     - `d`:目录
>     - `-`:文件
>     - `l`:链接文档
>   - 第`1-3`位表示该**文件的所有者的权限**
>     - 第`1`位为`r`表示文件**所有者**对该文件有**读的权限**,为**`-`**表示**没有读的权限**
>     - 第`2`位为`w`表示文件**所有者**对该文件有**写的权限**,为**`-`**表示**没有写的权限**
>     - 第`3`为为`x`表示文件**所有者**对该文件有**执行的权限**,为**`-`**表示**没有执行权限**
>   - 第`4-6`位表示**与该文件所有者同用户组的用户的权限**
>     - 表示相同
>   - 第`7-9`位表示**其他的用户的权限**
> - **注意**
>   - **对文件有写的权限不代表**可以**删除文件**,**只有**拥有对于该文件的**上级目录的写的权限**才**可以删除该文件**
>   - **可执行权限**对于**目录**而言就是**可以``cd``到该目录下的权限**,**可读权限**就是具备**``ls``显示该目录下的文件的权限**

- **使用`chmod`修改文件的权限**

  > `u`:文件所有者
  >
  > `g`:文件所属的用户组中的全部用户
  >
  > `o`:其他用户
  >
  > `a`:所有用户,即包括`u,g,o`在内的全部用户
  >
  > **两种变更方式**
  >
  > - ``chmod {ugoa}+{rwx} 文件名或目录名``
  > - ``chmod {421等搭配} 文件名或目录名``
  >   - `r=4,w=2,x=1`
  >   - `rwx=4+2+1=7`

  - **第一种方式**

    ```shell
    #给文件所有者添加权限
    	#读权限
    	chmod u+r 文件名或目录名
    	#写权限
    	chmod u+w 文件名或目录名
    	#执行
    	chmod u+x 文件名或目录名
    	#读写权限
    	chmod u+rw 文件名或目录名
    	#请自由搭配
    #给文件所属组添加权限
    #读权限
    	chmod g+r 文件名或目录名
    	#写权限
    	chmod g+w 文件名或目录名
    	#执行
    	chmod g+x 文件名或目录名
    	#读写权限 
    	chmod g+rw 文件名或目录名
    	#请自由搭配
    #给其他用户添加权限
    #读权限
    	chmod o+r 文件名或目录名
    	#写权限
    	chmod o+w 文件名或目录名
    	#执行
    	chmod o+x 文件名或目录名
    	#读写权限
    	chmod o+rw 文件名或目录名
    	#请自由搭配
    #给文件所有者与文件所属组添加权限
    #读权限
    	chmod ug+r 文件名或目录名
    	#写权限
    	chmod ug+w 文件名或目录名
    	#执行
    	chmod ug+x 文件名或目录名
    	#读写权限
    	chmod ug+rw 文件名或目录名
    	#请自由搭配
    #请自由搭配
    #给文件所有者添加执行权限,并个属组添加读权限
    chmod u+x,g+r 文件名或目录名
    ```

  - **第二种方式**

    ```shell
    #给其他用户添加权限
    	#读权限
    	chmod 4 文件名或目录名
    	#写权限
    	chmod 2 文件名或目录名
    	#执行权限
    	chmod 1 文件名或目录名
    	#读写权限
    	chmod 6 文件名或目录名
    	#读写执行权限
    	chmod 7 文件名或目录名
    #给文件所属组添加权限(以给其他用户添加所有权限为基础)
    	#读权限
    	chmod 47 文件名或目录名
    	#写权限
    	chmod 27 文件名或目录名
    	#执行权限
    	chmod 17 文件名或目录名
    	#读写权限
    	chmod 67 文件名或目录名
    	#读写执行权限
    	chmod 77 文件名或目录名
    #给文件所有者添加权限(以给其他用户与属组添加所有权限为基础)
    	#读权限
    	chmod 477 文件名或目录名
    	#写权限
    	chmod 277 文件名或目录名
    	#执行权限
    	chmod 177 文件名或目录名
    	#读写权限
    	chmod 677 文件名或目录名
    	#读写执行权限
    	chmod 777 文件名或目录名
    ```

  - **第三种方式`chmod -R`**

    ```shell
    #递归地给目录下所有文件与目录添加权限
    在chmod后加个-R即可
    ```

- **使用`chown`修改文件的所有者**

  ```shell
  #基本语法
  #将指定文件或目录的所有者修改为指定的最终所有者
  chown [选项] [最终所有者] [文件名或目录名]
  ```

  | `-R` | 递归地将目录下的所有文件与目录的所有者一并修改 |
  | ---- | ---------------------------------------------- |

- **使用`chgrp`修改文件所属的用户组**

  ```shell
  #基本语法
  #将指定文件目录的所属组修改为指定组
  chgrp [选项] [最终所属组] [文件名或目录名]
  ```

  | `-R` | 递归地将目录下的所有文件与目录的所有者一并修改 |
  | ---- | ---------------------------------------------- |

### 管道符

> - 管道符**可以连接**两个命令`命令1 | 命令2`,`ls | grep -n <字符串>`
> - 管道符会将`命令1`的**输出传递**给`命令2`,当然`命令2`**是否会使用就要看其特性了**

### 搜索功能

- **使用`find`查找指定文件或目录**

  > `find`:会在指定的搜索目录下递归地搜索该目录下所有文件,并找出符合要求的文件
  >
  > **查找模式符**(`\`转义字符可以将通配符转义为普通字符)
  >
  > - ``*``:匹配任意多个任意字符
  > - `?`:匹配一个任意字符
  > - `[]`:匹配一个括起来的字符中的任意一个
  >   - ``[0-9]``:匹配`0~9`范围上的$10$个数之一
  >   - `[a-zA-Z]`:匹配大小写的英文字母之一
  >   - `[^0-9]`:匹配不是``0~9``这十个数之一的任何一个字符
  > - `{匹配模式1,匹配模式2...}`:设置多个匹配模式,只要符合其一就认为匹配成功

  ```shell
  #基本语法
  find [搜索范围] [选项]
  #查找以.log为后缀,属于tangling的大小超过2MB的文件
  find /etc/ -name "*.log" -user tangling -size +2048k
  ```

  | 选项                                                         | 作用                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | `-name<查找模式>`                                            | 按照指定的查找模式查找                                       |
  | ``-user<用户名>``                                            | 指定查找的文件的所有者                                       |
  | `-size<{+|-|不加}文件大小>`<br />`+`表示大于<br />`-`表示小于<br />不加表示等于 | 指定文件的大小<br />``b``:块<br />`c`:字节<br />`w`:字<br />`k`:千字节<br />`M`:兆字节<br />`G`:吉字节 |

- **使用`locate/plocate`递归的查出指定目录下的所有文件**

  ```
  #递归的查找出/home/tangling/下载/ 目录下的所有文件
  plocate /home/tangling/下载/
  ```

- **使用`grep`+`|`管道符实现过滤查找**

  > **基本格式**:`grep [选项] <字符串(可以带通配符)> 路径/要匹配的文件的名称`
  >
  > `grep`可以**在指定内容中**查找**指定字符串是否存在**,若**存在则显示所有含该字符串的行**
  >
  > - ``-n``:**额外显示其在内容的第几行**
  >
  > **注意**:`grep`**可以接收管道符传递的信息**,此时格式为`命令1 | grep -n <字符串>`

### 压缩解压缩相关

- **使用`gzip/gunzip`压缩/解压缩文件**

  > **特性**
  >
  > - **只能**用于**文件**的解压缩
  > - **解压缩后原来的**文件会被**删除**
  > - **同时压缩多个**文件会**产生多个`.gz`压缩包**
  >
  > **注意事项**
  >
  > - 当某个文件解压缩失败时原文件不会被删除
  >
  > - 解压缩多个文件时可能有些文件由于权限问题无法正确解压缩.这就会有如下问题
  >   - `gzip 文件1 文件2`:第一个文件没有权限,那么结果是`文件1`压缩失败(`文件1`没有被删除),`文件2`压缩成功(`文件2`被删除了).
  >   - `gunzip 文件1.zip 文件2.zip`:第一个文件没有权限,那么结果是`文件1`解压失败(``文件1.gz``没有被删除),`文件2`压缩成功(`文件2.gz`被删除了).

  ```shell
  #将指定路径下的指定文件A压缩为指定路径下的  文件名A.gz文件
  gzip 路径/文件名A
  #将指定路径下的指定 文件名A.gz 文件解压为指定路径下的文件名为 文件名A 的文件
  gunzip 路径/文件名A.gz
  
  #压缩多个文件
  gzip 路径/文件名 路径/文件名
  #解压多个文件
  gunzip 路径/文件名.gz 路径/文件名.gz
  ```

- **使用`zip/unzip`压缩/解压缩文件或目录**

  > **基本语法**
  >
  > - `zip [-r] 压缩后的文件名.zip 要压缩的内容1 [要压缩的内容2...]`
  > - `unzip 要解压的文件名.zip [-d 解压后的文件的存储目录]`
  >
  > `-r`:在`zip`时使用,用于**递归压缩**
  >
  > `-d`:在`unzip`时使用,用于**指定解压后**的文件的**存储目录**
  >
  > **特性**
  >
  > - **解压缩后不会删除原`.zip`压缩文件或被压缩的文件**
  >
  > - 当**压缩的**是**多个文件**时,会将这些**文件都压缩到**`压缩后的文件名.zip`文件中,而**解压时**,这些文件也会**被同等级地存储**
  > - 可以**同时**压缩**文件**与**目录**
  > - **只要**压缩的内容中**有一个是目录**,那么我们就**必须添加**`-r`参数

  ```shell
  #压缩
  #压缩单个文件
  zip text.txt.zip ./text.txt
  #压缩多个文件
  zip union.zip ./test1.txt ./test2.txt
  #压缩目录
  zip -r test.zip /home/tangling/下载
  #压缩文件与目录
  zip -r test.zip /home/tangling/下载 ./test1.txt
  
  #解压
  #解压文件到当前目录
  unzip test.zip
  #解压文件到/home/tangling 目录下
  unzip test.zip -d /home/tangling
  ```

- **使用`tar`打包/解包文件**

  > **`tar`的作用**:我们知道`gzip`压缩命令**一次虽然可以压缩多个文件**,**但是**会分别压缩他们,**生成多个压缩文件**,而我们的`tar`的作用就是在`gzip`压缩前**使用`tar`指令将指定的多个文件打包为一个`.tar`文件**,然后我们**只需要**使用`gzip`**压缩这一个文件**就可以**实现**将**多个文件压缩在一起**
  >
  > **特性**
  >
  > - 当`-f`和其他指令写一起时,如`-zxvf,-zcvf`那么语法变成
  >   - `tar -zxvf 路径/目的文件名.tar.gz 要压缩的内容1 [要压缩的内容2...]` 
  > - 当`-f`单独写时,语法如下
  >   - `tar -zxv 要压缩的内容1 [要压缩的内容2...] -f 路径/目的文件名.tar.gz` 

  | 选项 | 功能                                                         |
  | ---- | ------------------------------------------------------------ |
  | `-c` | 产生`.tar`打包文件                                           |
  | `-v` | 显示详细压缩过程                                             |
  | `-f` | 指定压缩后的存储位置以及文件名                               |
  | `-z` | 与`-c`一起使用,表示打包后将`.tar`打包文件压缩为`.gz`文件<br />与`-x`一起使用,会将`.tar.gz`文件解压为`.tar`文件 |
  | `-x` | 解包`.tar`文件                                               |
  | `-C` | 指定解压后的存储位置以及文件名                               |

  ```shell
  #我们可以对选项进行合理的组合实现不同的功能
  #选项的前后不影响其执行顺序
  -zcvf:
  	c:表示先打包指定文件为.tar文件
  	z:然后将文件压缩为.gz格式
  	f:然后存储到指定位置
  	v:并且显示打包压缩的详细过程
  ```

### 磁盘查看与分区

- **使用`du`递归地查看指定目录的磁盘占用情况或查看指定文件的内存占用情况**

  > - 当**目标是目录**时(如果不添加`-a`参数),**则只会递归地**列出**该目录下所有的目录**的磁盘占用,**而文件**是**会被直接过滤**而**不被展示**的
  > - 当目标是文件时,会显示该文件的磁盘占用情况

  | 选项            | 功能                                                         |
  | --------------- | ------------------------------------------------------------ |
  | `-h`            | 以`KBytes,MBytes,GBytes`等为单位                             |
  | `-a`            | 使得结果中额外包括文件                                       |
  | `-c`            | 不改变原来的内容，在原来的内容显示完成后,显示所有内容的磁盘占用总和 |
  | `-s`            | 只显示总和,原来的内容被取消显示                              |
  | ``–max-depth=`` | 指定最大递归深度                                             |

  ```shell
  du /home/tangling/下载/Clash
  
  cd /home/tangling/下载
  du test.txt
  ```

- **使用`df`查看当前磁盘的剩余空间**

  > - 可以使用`-h`选项让结果以`KBytes,MBytes等`显示

  ```shell
  df -h
  ```

- **使用`lsblk`查看设备挂载情况**

  > 可以使用`-f`显示详细信息

  ```shell
  lsblk -f	
  ```

- **使用`mount/unmount`挂载/卸载设备**

- **使用`fdisk`查看磁盘分区情况**

### 进程管理类

- **使用`ps`查看当前系统进程的运行情况(类似于``Windows``任务管理器)**

  | 选项 | 功能                                              |
  | ---- | ------------------------------------------------- |
  | `a`  | 列出**当前用户**带有**终端**的所有用户的进程      |
  | `x`  | 列出**当前用户**的所有进程,包括**没有终端**的进程 |
  | `u`  | 以面向用户的友好风格显示                          |
  | `-e` | 列出所有进程(**所有用户**)                        |
  | `-u` | 列出**某个用户**关联的所有进程                    |
  | `-f` | 显示完整的格式                                    |

  - **显示信息说明**

    > `USER`:进程所属的用户	`PID`:进程的进程号	`%CPU`:进程占用的CPU百分比	`$MEM$`:该进程占用的物理内存百分比
    >
    > `VSZ`:该进程占用的虚拟内存大小,单位为`KB`	`RSS`:该进程占用的实际物理内存的大小,单位为`KB`
    >
    > `TTY`:进程所属的终端
    >
    > - `tty1`:图形化终端
    > - `tty2-6`:字符界面终端
    > - `pts/0-255`:虚拟终端
    >
    > `SATA`:进程的状态]
    >
    > - `R`:运行	`S`:睡眠	`T`:暂停	`Z`僵尸	`s`:包含子进程	`l`:多线程	`+`:前台显示
    >
    > `START`:进程启动的时间
    >
    > `TIME`:进程占用`CPU`资源的时长
    >
    > `COMMAND`:产生该进程的命令
    >
    > `UID`:进程所属用户的``ID``
    >
    > `PPID`:进程的父进程的`PID`
    >
    > `C`:该进程的`CPU`优先级,数值越大优先级越低
    >
    > `STIME`:进程的启动的时间
    >
    > `CMD`:同`COMMAND`
    >
    > 

- **使用`pstree`查看进程树**

  | 选项 | 功能             |
  | ---- | ---------------- |
  | `-p` | 显示进程`PID`    |
  | `-u` | 显示进程所属用户 |

- **使用`kill`终止进程**

  > 可以使用`-9`强制终止

  ```shell
  #根据进程号终止
  kill 进程号(PID)
  #根据进程名终止
  killall "进程名"
  #根据带通配符的字符串关闭
  killall "带通配符的进程名"
  ```

- **使用`top`进入系统进程的运行状态实时监控状态**

  - **进入选项**

    | 选项 | 功能                        |
    | ---- | --------------------------- |
    | `-d` | 指定更新秒数                |
    | `-i` | 不显示闲置以及僵尸状态进程  |
    | `-p` | 使用``PID``指定监视指定进程 |

  - **状态内功能**

    | 操作 | 功能                |
    | ---- | ------------------- |
    | `P`  | 以``CPU``使用率排序 |
    | `M`  | 以内存使用率排序    |
    | `N`  | 以`PID`排序         |
    | `q`  | 退出`top`           |

- **使用`netstat`显示网络状态以及端口占用情况**

  | 选项 | 功能                     |
  | ---- | ------------------------ |
  | `-a` | 显示所有套接字           |
  | `-n` | 拒绝显示别名             |
  | `-l` | 只列出在监听状态的套接字 |
  | `-p` | 显示调用该套接字的进程   |

## `Linux`为什么么又要有`.tar与.gz`又要有`.zip`呢?为什么不直接使用`.zip`呢?

> `zip`:仅仅**是简单的压缩文件**,其**不会保存`Linux`下文件的权限**,当我们压缩了文件后,其**所具备的文件权限就会失效**,当我们解压后则需要通过`chmod,chown`修改来**自己手动恢复文件的权限**
>
> `.tar`:该文件类型仅仅**只是打包文件**,并未压缩,其**打包后的文件保存有其文件权限**,并且当**压缩为`.gz`后也可以正确保留其文件权限**,当我们解压并解包后**无需手动修改其文件权限就会是正确的**

## `Linux`管道符的妙用

## `Linux`软件包管理

### `Linux`的`apt`软件包管理

<img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709135138371.png" alt="image-20220709135138371" style="zoom:80%;" />

### `Linux`的`rpm`软件包管理

### `Linux`的`yum`软件包管理

### `Linux`的``apt-get``软件包管理

<img src="F:\A_Java_DataBase_Study_FIle\Linux\LInux基础.assets\image-20220709135228393.png" alt="image-20220709135228393" style="zoom:80%;" />

## `Linux`常用快捷键

| 常用快捷键   | 功能               |
| ------------ | ------------------ |
| **CTRL+ C**  | **终止运行**       |
| **CTRL + L** | **清屏,等价于**    |
| **TAB**      | **自动补齐**       |
| **上下键**   | **寻找以前的命令** |

