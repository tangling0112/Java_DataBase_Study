## 前置知识

- **同一个`.java`文件中可以有多个类,但必须只有且必须有一个类是`public`公共类**
- **当一个`.java`程序文件中定义了多个类时,调用`javac.exe`编译会生成多个`.class`文件其与我们的`.java`文件中的各个类是一一对应的,并且`.class`文件名就是与其对应的`Java`类的文件名**
- **`public`类名最好与我们的`.java`程序文件名一致.**
  - **后果**:由于`.class`字节码文件会根据我们类的名称进行命名,因此保证`public`类名与`.java`文件名同名可以解决许多不必要的问题

# `Java`关键字汇总

> **关键字都为小写**
>
> - 注意`goto`与`const`被`Java`作为保留字

![image-20220714223439476](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220714223439476.png)

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220714223501101.png" alt="image-20220714223501101" style="zoom:97%;" />

# `Java`数据类型与**数据类型转换**

### 基本数据类型

![image-20220714224923016](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220714224923016.png)

#### 整数类型

![image-20220714225125108](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220714225125108.png)

#### 浮点类型

![image-20220714225436872](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220714225436872.png)

#### `char`字符类型

> - `2字节`
> - `Unicode`编码
> - 字符常量必须用`''`方式包括
> - 可以用`'\uXXX'`的方式来指定字符,也就是直接用字符对应的(**16进制**)`Unicode`编码来指定字符

#### `Boolean`布尔类型

> - 只能取`true`与`false`两个值

## 基础数据类型的强制转换

- **基本语法**:`(数据类型)变量`
- **问题**:可能会导致精度损失
- ==**注意:只有八个基本数据类型之间可以进行强制转换**==
  - **例如**:`int`不能强制转换为`String`

## 基础数据类型的自动转换

- **自动类型转换的基本规则**
  - **容量小**的数据类型**与容量大**的数据类型**进行运算**时,会先将**容量小的数据类型自动转换为容量大**的数据类型,然后再进行运算
  - **若是单纯的`byte,char,short`三者之间的运算,那么他们会被直接转换为`int`类型然后进行计算**
    - 并且他们自己和自己运算也会直接转换成`int`再运算
  - `Boolean`类型不能参与运算
  - **`比较运算,赋值运算,算术运算`的运算符都涉及自动类型转换**
- **数据类型容量排序**
  - ![image-20220714231926519](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220714231926519.png)

## `String`类型的数据类型转换

> - **`String`类型只能与八种基本数据类型进行`+`连接运算**

#### 运算规则

```java
char a = 'a';
int b = 10;
String c = "acc"

a+b+c;"107acc"
a+c+b;"aacc10"
b+c+a;"10acca"
c+b+a;"acc10a"
b+a+c;"107acc"
```

## `Java`进制转换

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715174325234.png" alt="image-20220715174325234" style="zoom: 50%;" />

# `Java`运算符

## 算术运算符

![image-20220715180918118](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715180918118.png)

## 赋值运算符

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715181037345.png" alt="image-20220715181037345" style="zoom: 67%;" />

## 比较运算符

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715182041727.png" alt="image-20220715182041727" style="zoom: 67%;" />

## 逻辑运算符

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715182208958.png" alt="image-20220715182208958" style="zoom:67%;" />

## 位运算符(只涉及整数)

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715182431332.png" alt="image-20220715182431332" style="zoom:67%;" />

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715182546112.png" alt="image-20220715182546112" style="zoom:64%;" />

## 三元运算符

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715183027394.png" alt="image-20220715183027394" style="zoom:67%;" />

## `Java`运算符优先级

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715183314522.png" alt="image-20220715183314522" style="zoom:67%;" />

### 注意事项

- **基本数据类型的运算与引用数据类型的运算是不同的**.**基本数据类型**的类型自动变更为**自动类型转换**,而**引用数据类型**的类型变更为**自动转型**

# `Java`流程控制结构

> <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715184459221.png" alt="image-20220715184459221" style="zoom:50%;" />

## 顺序结构

## 分支结构

> - **`if`**
> - **`if else`**
> - **`if else if else`**
> - **`switch case`**
>   - **注意**:条件表达式的数据类型只能是下面六者之一
>     - `byte`
>     - `short`
>     - `char`
>     - `int`
>     - `String(JDK7.0新增)`
>     - `枚举类型(JDK5.0新增)`
> - **分支结构可以任意嵌套**

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715184524016.png" alt="image-20220715184524016" style="zoom:50%;" />

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715184550728.png" alt="image-20220715184550728" style="zoom:50%;" />

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220715184954911.png" alt="image-20220715184954911" style="zoom: 50%;" />



## 循环结构

> **注意:循环结构与`C++/C`完全相同原理**
>
> - **`for(;;;){}`**
> - **`while(){}`**
> - **`do{}while();`**

# `Java`数组

## 一维数组

> **`Java`数组与`C/C++`数组特性相同**

### 数组初始化

- **静态初始化数组**

  ```java
  数据类型[] 数组名;
  数组名 = new 数据类型[]{数据};
  ```

- **动态初始化**

  ```java
  数据类型[] 数组名 = new 数据类型[数组容量]
  ```

### 数组索引与取值

> **与`C/C++`相同**
>
> - 索引从`0`开始
> - 通过`[]`来进行索引
> - **如果我们使用动态方式创建数组,那么数组元素的默认初始化值如下**
>   - `int/short/byte`数组:**默认值为`0`**
>   - `float/double`数组:**默认值为`0.0`**
>   - `char`数组:**默认值为``''``空字符**
>   - `boolean`数组:**默认值为`false`**
>   - `String`数组:**默认值为`null`**

### 常用属性与方法

#### 属性

- **`.length`**:返回数组的长度,**即数组最大可容纳的元素的个数**

## 二维数组

> **`Java`的二维数组的原理与`C/C++`的自建`二维非连续数组`相同.二维数组就是数组里面存储着数组,即数组的元素不再是简单的数据类型,而是一维度数组**
>
> **注意**:==**`Java`的二维数组与`C/C++`不同,其数组的各个行的列数可以不同,即`Java`中数组不需要各行的列数相同**==
>
> - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220716113826290.png" alt="image-20220716113826290" style="zoom:67%;" />
>
> **二维数组的默认初始化值**
>
> - **外层数组(即通过`数组名[]`索引的)**
>   - 其默认值是一个指针,指向我们系统分配给数组某一行的堆空间的首地址
> - **内层元素(即通过`数组名[][]`索引的)**
>   - 其默认值情况与我们的一维数组的情况相同

### 定义与初始化

```java
//标准方式
	//静态初始化
数据类型[][] 数组名 = new 数据类型{{数据},{数据}...};
数据类型[][] 数组名 = new 数据类型{{3,2,1},{4,6},{7,8,9}};
//这个数组的第一行列数为3,第二行列数为2,第三行列数为3

	//动态初始化
数据类型[][] 数组名 = new 数据类型[行数][列数]
    
数据类型[][] 数组名 = new 数据类型[行数][]
//注意:由于只声明了该二维数组有三行,但是并没有给每一行对应的数组授予内存空间,因此我们使用时,必须先用数组名[行索引] = new 数据类型[该行想要赋予的列数]的方式来进行初始化

//特殊方式1    
数据类型[][] 数组名 = {{数据},{数据}}
数据类型[][] 数组名 = 数据类型{{3,2,1},{4,6},{7,8,9}};
数据类型[][] 数组名 = 数据类型[行数][列数]
数据类型[][] 数组名 = 数据类型[行数][]
    
//特殊方式2
数据类型[] 数组名[] = new 数据类型{{数据},{数据}...};
数据类型[] 数组名[] = new 数据类型{{3,2,1},{4,6},{7,8,9}};
数据类型[] 数组名[] = new 数据类型[行数][列数]
数据类型[] 数组名[] = new 数据类型[行数][]
```

### 索引与取值

```java
数组名[行索引][列索引]
```

### 基本属性与方法

#### 属性

- **`.length`:输出**

## 数组元素的赋值

> 数组元素的赋值与`C/C++`相同

****

# `Java`类与对象

## 基础概述

### `Java`类的组成结构

> - **属性(又称域,字段)**:相当于`C++`的成员变量
> - **方法**:相当于`C++`的成员函数
> - **构造器**:相当于`C++`的构造函数与析构函数
> - **代码块**
> - **内部类**:相当于`C++`的类中类的使用

****

### 面向对象的三大特征

> - **封装**
> - **继承**
> - **多态**

****

### 面向对象的相关关键字解读

> - `class`:
> - `this`:
> - `super`:
> - `static`:
> - `final`:
> - `abstract`:
> - `interface`:
> - `package`:
> - `import`:

****

### 面向过程与面向对象的对比

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220716133830266.png" alt="image-20220716133830266" style="zoom: 33%;" />

### 面向对象方法论

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220716134318497.png" alt="image-20220716134318497" style="zoom: 33%;" /><img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220716134605028.png" alt="image-20220716134605028" style="zoom: 33%;" />

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image_71.png" alt="image_71" style="zoom: 33%;" />

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220716135033768.png" alt="image-20220716135033768" style="zoom: 50%;" />

****

## `Java`类的各种组成的存储特性

- **`属性`:**非静态属性存储在内存的``堆区``,静态属性存储在内存的`方法区的静态池`
- **`方法`:**非静态方法存储在内存的``方法区``,静态方法存储在内存的`方法区的静态池`
- **`局部变量`**
  - **方法中的变量即为局部变量**
  - **基础数据类型`直接存储在栈区`**
  - **引用数据类型则在`栈区存储指针`,在`堆区存储实际内容`**

- **`构造器`:**
- **`内部类`:**

****

## `Java`类属性与方法的声明

- **类属性**

  ```java
  [public|private|protected] [static] 数据类型 属性名
  ```

- **类方法**

  ```Java
  [public|private|protected] [static] 数据类型 方法名(形参列表){语句体}
  ```

## `Java`类方法与类属性的存储特性

### 非`static`情况

- **类方法**
  - 对于同一个类而言,无论存在多少个该类的类实例,**在我们的内存中类方法都是唯一存储在内存的方法区中**的.这些类方法**在我们的第一个类实例被实例化时创建**,**之后的**任何类实例的实例化都**不会再涉及到类方法的创建**.**所有的类实例共享同一个类方法**.
- **类属性**
  - 对于同一个类而言,该类的每一个实例化对象**都具有其独占的存储在内存堆区的类属性**,这些类属性在我们的**对象被实例化时由系统为我们创建**.各个类实例的类属性之间不存在直接的相互影响.
  - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java重要工作原理解析.assets\image-20220716140558567.png" alt="image-20220716140558567" style="zoom: 33%;" />

****

### `static`情况

- **静态类方法**
  - 静态类方法基本具有与普通类方法类似的特性,只不过**静态的类方法是在我们程序开始运行时就会在内存上创建出来,而不是等到该类的第一个实例被实例化时创建**.因此即便我们**不实例化类**,也是**可以访问到该类的静态类方法**的.
- **静态类属性**
  - 静态类属性不同于普通属性,首先其**创建时机是在我们的程序准备开始运行时就会被创建**出来的,其次静态类属性不同于普通类属性的不同类实例独占,**静态类属性是被所有类实例共享的**.

****

## **`Java`权限修饰与静态修饰**

> **其含义与`C++`基本完全相同**
>
> - **修饰类**只能使用`private`或`public`
> - 修饰`属性,方法,构造器,内部类`可以**使用所有的这四种权限修饰符**

****

### 四种权限修饰符对于`继承性`的影响

- :one:**`public`**
  - **使用`public`修饰的父类属性或方法可以被继承了该类的子类直接访问(如``子类实例.父类属性``,``子类实例.父类方法``,`子类内部方法访问`)**
  - 当然**也可以**通过**继承得到**的**父类方法进行访问**

- :two:**`private`**
  - 使用`private`修饰的父类属性或方法**不能**被继承了该类的**子类直接访问**(如``子类实例.父类方法``,`子类实例.父类属性`,`子类内部方法访问`)
  - 由于父类的方法是会被继承到子类中的,因此我们**可以通过**`子类实例.父类方法`的方式**通过`父类方法`访问父类的`private`修饰的`属性,方法`**

- :three:**`protected`**
  - 使用`protected`修饰的父类属性或方法**可以**被继承了该类的**子类访问**(如``子类实例.父类属性``,``子类实例.父类方法``,`子类内部方法访问`)
  - 当然**也可以**通过**继承得到**的**父类方法进行访问**

- :four:**缺省**
  - **权限大于`private`小于`protected`**

****

### 四种权限修饰符对于`类方法,类属性`的影响

- **`private`**
  - **只能**被**`类内`**的方法访问
  - **不可以在`同一个包下`的其他类中**`直接`通过`类实例.`的方式调用
  - **不可以**借助`import`**被`不同包下`的`继承`该类的子类通过`子类实例.`的方式调用**
  - **不可以**借助`import`在`不同包下`的类中`直接`通过`类实例.方法名`的方式调用
  - **不可以被同一个工程下的其他类调用**
- **缺省**
  - **可以**被**类内方法**访问
  - **可以在`同一个包下`的其他类中**`直接`通过`类实例.`的方式调用
  - **不可以**借助`import`**被`不同包下`的`继承`该类的子类通过`子类实例.`的方式调用**
  - **不可以**借助`import`在`不同包下`的类中`直接`通过`类实例.方法名`的方式调用
  - **不可以被同一个工程下的其他类调用**
- **`protected`**
  - **可以**被**`类内`**方法访问
  - **可以在`同一个包下`的其他类中**通过`类实例.`的方式调用
  - **可以**借助`import`**被`不同包下`的`继承`该类的子类通过`子类实例.`的方式调用**
  - **不可以**借助`import`在`不同包下`的类中`直接`通过`类实例.方法名`的方式调用
  - **不可以被同一个工程下的其他类调用**
- **`public`**
  - **可以**被**类内方法**访问
  - **可以在`同一个包下`的其他类中**通过`类实例.`的方式调用
  - 可以借助`import`**被`不同包下`的`继承`该类的子类通过`子类实例.`的方式调用**
  - **可以**借助`import`在`不同包下`的类中`直接`通过`类实例.方法名`的方式调用
  - **可以被同一个工程下的其他类调用**

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220804200800559.png" alt="image-20220804200800559" style="zoom: 67%;" />

****

### 权限修饰符对`类`的影响

> **类只支持`public`与`private`两种权限修饰符**

- **`public`**
  - 在`import`的帮助下可以被其**所在包中的其他类调用**,可以**被其他包中的类调用**,也**可以被不同工程下的其他类调用**
- **`private`**
  - 可以**被其所在包下的其他类调用**,其他的任何调用都不支持

****

### 静态修饰符`static`的作用

> `static`可以用于修饰`类方法,类属性,代码块,内部类	`

- :one:所有的实例化对象**共享一个静态成员变量**,一个实例化对象**修改了静态成员变量**,那么其他实例化对象在访问该静态成员变量时,**就得到的是修改后的值**
- :two:在**编译阶段**静态成员变量以及静态成员函数便**分配好了地址在全局区相对于我们程序首地址的偏移量**(一般的成员变量是在类实例化时获得内存分配,并且**实例化多个类对象就会有多个`存储在不同内存地址`的从属于不同类对象的成员变量)**
- :three:静态成员函数**只能访问静态变量**
- :four:静态的方法可以直接通过`类名.静态方法名()`的方式直接访问,静态属性也同理.**无需借助实例化的类**

****

## `Java`类的实例化

- **方式1**

  ```java
  类名 对象名 = new 类名();
  类名 对象名 = 已实例化的对象名;
  ```

- **方式2**

  ```java
  类名 对象名 = new 类名(传入类的构造器的实际参数);
  ```

## `Java`对象数组

> **即以我们的自定义类的类实例来作为我们数组的元素**

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220804161037178.png" alt="image-20220804161037178" style="zoom:67%;" />

## `Java`匿名对象

> - `Java`的匿名对象与`C++`的匿名对象是同理的,并且也可以拓展到匿名数据类型
>
> **作用**
>
> - 在**不实例化出一个具体的对象**的情况下**调用指定类的`非静态方法`与`非静态属性`**

- **使用方式**

  ```java
  new 类名().方法名(<实参列表>);
  new 类名().属性名;
  ```

- **原理**

  - 其利用我们`Java`的**自动垃圾回收机制**用`new 类名()`的方式实例化了一个类,然后我们就调用这个类的方法或属性,而当我们**执行完**当前语句后,`Java`就会**直接将我们使用的类直接作为垃圾收回**掉.

    ```java
    new 类名() --->  得到一个地址
    类名 对象名 = new 类名() --->  //将new 类名()得到的地址赋给对象名保存
    //原理  
    对象名.方法名()   ====    new 类名().方法名()
    对象地址.方法名()  ====  对象地址.方法名()
    ```

## `Java`方法的一些特性

### 方法重载(`OverLoad`)

> **`Java`的方法重载实际上就是我们`C/C++`中的函数重载**
>
> **定义**
>
> - 方法重载即允许同一个类中的同一个作用域下存在多个同名的方法,**只要这些方法的形参个数,形参数据类型不完全相同即可.**
>
> **原理**
>
> - **`Java`使用函数签名来唯一标识一个函数,而函数签名则由该函数的函数名以及形式参数列表生成**
>
> - 由于形参个数,形参数据类型不完全相同,因此当我们对方法进行调用时,`Java`程序就**可以通过我们给出的实参确定出我们访问的是同名函数中的哪一个**
>
> **作用**
>
> - 例如对于一个实现两数相加的方法`add()`,显然我们存在`浮点数+整数,浮点数+浮点数,整数+整数`等等多种不同的数据类型之间的加法.通过方法的重载,我们可以建立多个`add()`函数,针对我们不同的实际参数调用不同的`add()`函数,从而正确地实现我们的两数相加.
>
> **注意事项**
>
> - **形式参数数据类型完全相同,只不过顺序不同**是**能够满足**方法重载的**条件**的
> - **方法签名与其`权限修饰,返回值类型,是否静态`均无关,只与方法名以及形参数据类型列表有关**

****

### 可变个数的形参

> **基本概念**
>
> - 即定义一个形式参数,使得其**可以接收多个同一类型的数据**.
>
> **本质**
>
> - `String ...a`本质上等价于`String[] a`,只不过在语法上`Java`为我们自动进行了一些操作,使得前者的使用相较于后者更简单
>
> **注意事项**
>
> - 可变个数形参是可以参与方法重载的.`String a`与`String ...a`是被看作不同的数据类型的
> - 由于`String ...a`等价于`String[] a`因此,`String ..a`与`String[] a`在方法重载是被认为是同一数据类型
> - 可变个数形参在形参列表中**只能存在一个**,且**必须是**形参列表的**最后一个**形参.

****

#### 使用方式

- **可变个数形参的定义**

  ```java
  //形参名3即为我们定义的可变个数的形式参数
  [public|protected|private] [static] 数据类型(数据类型 形参名1,数据类型 形参名2,数据类型 ...形参名3)
      
  //例
  public void test(int a,double b,String ...s){}
  ```

- **方法中获取可变个数形参中存储的指定数据**

  ```java
  可变个数形式参数名[索引值]
  ```

****

### **方法参数的值传递机制**

> 不同于`C++`在进行参数传递时具备`值传递,指针传递,引用传递`,**在`Java`中只有值传递一种,也就是与我们的`C`语言是类似的**
>
> **特点**
>
> - 由于`Java`中**只有值传递这一中参数传递机制**,因此无论如何我们的形式参数都会先获取一片新的存储空间然后再将我们传递的实际参数的内容保存到我们新获取的这一片空间中,**当然值得注意的是,由于传地址是可行的,因此`Java`也无法避免``C++``中的传递时的`深拷贝与浅拷贝`问题**
>
> **注意**
>
> - :one:**地址**也是会被作为一个实际的值**正确参与`值传递`的**
> - :two:`Java`的传参与`C`语言传参的原理**基本完全相同**
> - :three:与`C`语言一样**无论是基础数据类型与引用数据类型**,变量其实**都是保存的地址值**,只不过**基础数据类型的应用范围广**,因此在传参时**对基础数据类型的参数传递进行了优化**,使得我们的**程序总会将我们基础数据类型`当作一个指定数据类型的常量来接收`,而不是传地址来直接共享同一片内存空间的使用**
>
> **问题**
>
> - 由于是`值传递`,因此对于**基本数据类型**而言就是**新建了一个变量来接收我们传过来的值**,但是呢,对于我们的**引用数据类型如数组,类等而言**,由于数组名,类实例名**实际上都保存的是一个地址**,因此即便**`值传递`也是传递地址**,因此对于引用数据类型而言,我们的**子函数中是可以和主函数共享使用同一个引用数据类型的变量**
>   - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220804174301503.png" alt="image-20220804174301503" style="zoom:50%;" />

- **基本数据类型值传递示例**

  ```java
  //函数的定义
  public void test(int a,double s)
  //函数的调用
  test(10,"jklove")
  //实际上上述就等价于
  int a = 10;
  double s = "jklove";
  ```

  <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220804174301503.png" alt="image-20220804174301503" style="zoom:50%;" />

- **引用数据类型值传递示例**

  ```java
  //函数定义
  public void test(String s)
  //函数调用
  test(str1)
  //实际上上述就等价于
  String s = str1//str1是主函数中的一个String类型变量,其存储的值是一个指向内存堆区的某个位置的指				  针,因此这一句就等价于让我们的s接收了一个指针.
  ```

  <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220804175941174.png" alt="image-20220804175941174" style="zoom:50%;" />

****

#### 基于`可变个数形式参数`的也是`无法`让子函数可以修改主函数的基础数据类型变量

```java
//定义子函数
public void test(int ...c)
//调用子函数,a,b为主函数中的两个int型变量，a=10，b=20
test(a,b)
//上述操作实际等价于
int[] c = {10,20};
//而不是等价于
int[] c = {a,b};
```

****

### 方法的`递归`

> 实际上`Java`中方法的递归就与我们的`C/C++`的函数的递归是相同的原理,**即`方法内部调用自己本身`**

#### 递归的核心组成

- **递归终止条件**
  - **即一个条件分支语句**,使得我们的递归调用不会无限制地递归下去,而是到一个指定的程度便停止递归,开始反向传递结果
- **递归方法调用**

## **`Java`类的封装性**

### 封装的介绍

> **封装的含义**
>
> - `封装`即**将一个对象的各种属性,方法用类包裹起来**,并将其中**需要提供给外界使用的属性与方法公开**,而**其他的属性与方法则隐藏在类的内部**.当我们希望操作该对象时,我们**只需要借助这些公开的属性与方法即可**,而其**内部究竟如何实现我们的目的,则无需我们关系**
>
> **封装的作用**
>
> - **保证`高内聚,低耦合`**
>   - `高内聚`:大量的复杂操作都被包裹在我们的类中
>   - `低耦合`:类仅仅指向外接呈现出必要的接口以供调用.其他的复杂操作则被隐藏起来
> - **确保`易用性`**
>
> **总结**
>
> - 把**该暴露的公开出来**作为类的公开属性,方法
> - 把**过于复杂无需暴露的隐藏起来**,以**减轻用户使用负担**
>
> **如何实现封装**
>
> - 我们通过借助**四大权限修饰符**既可以实现暴露需要暴露的,隐藏需要隐藏的

## **构造器(构造方法)**

> **作用**
>
> - 构造器其实就等价于我们`C++`中的**构造函数**
>
> **构造器的特性**
>
> - 构造器会在我们的**类实例化时自动调用**.
>
> **注意事项**
>
> - :one:在调用构造器时应该注意避免**构造器中调用构造器自己**,从而**导致构造器的递归调用,无法终止**
> - :two:如果一个类中**定义了`N`个构造器**,那么该类**最多只能有`N-1`个构造器**中**使用`this()`调用构造器,而剩下的那个类一定会调用`super()`**
> - :three:**只有在**构造器中**才可以使用`this()`的方式调用构造器**,在**普通的类方法中`this()`是不可用的**
> - :four:在任何构造器中,如果要用`this()`调用构造器,都**必须在该构造器的首行进行`this()`调用**
> - :five:由:four:我们知道,一个构造器最多只能使用`this()`调用**有且只有一个其他的构造器**
>
> - :six:由于我们的`Java`**只有`值传递`机制**,因此我们的`Java`**不同于**`C++`有`无参构造函数,有参构造函数,拷贝构造函数`**三种类型的构造函数**,而是**只具有`无参构造器,有参构造器两种`**
> - :seven:**只有子类构造器的首行**可以使用`super`调用父类构造器
> - :eight:当我们子类构造器的首行**没有使用**`this()`或`super()`调用构造器时,我们的`Java`编译器会**自动**为我们的**子类构造器的首行**添加`super()`来**调用父类的无参构造器**
> - :nine:通过`this`调用构造器**只能在当前类的构造器的首行才合法**
> - ==🔟由:two:我们可以明确,**无论如何我们的子类构造器最终都会调用父类的构造器**,因此子类实例化时会自动调用子类的构造器,而子类的构造器最终都会调用父类的构造器,**因此无论如何子类的构造器调用之前都会先调用父类的构造器**==
>   - **原因**
>     - 首先我们通过调用子类的构造器希望实例化我们的子类
>     - 然后我们的子类构造器的首行**要么调用`super`要么调用`this`**
>       - 调用`super`则会**调用父类的构造器**
>       - 调用``this``则会**调用子类的另一个构造器**,**另一个构造器又会面临同样的选择**,而我们的构造器中至少有一个首行会调用`super`,**因此我们可以看作一个递归过程**,**无论如何最终都会需要通过调用``super``来终止递归.**
>   - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220806195502311.png" alt="image-20220806195502311" style="zoom:67%;" />
> - `11`:由于**`Object`类是没有父类的**,因此`Object`类的**构造器中不会有自动添加`super()`这样的行为**.而又由于`Object`类**是我们所有类的最根源的父类**,因此**任何一个构造器的递归调用过程都会通过`Object`类的空参构造器的调用而终止**
> - `12`:==**构造器虽然可以被继承但构造器无法被重写**==**

****

### 构造器的创建

> **注意**
>
> - :one:对于有参构造器而言,我们**应该知道其也是可以重载**的,根据**形参列表的不同**,可以**定义多个不同的有参构造器**
> - :two:无参构造器与有参构造器其实**都是基于形参列表的不同**来对构造器进行的**重载**

- **无参构造器**

```java
class Testclass{
    public Testclass(){语句体}
}
```

- **有参构造器**

```java
class Testclass{
    public Testclass(形参列表){语句体}
}
```

#### 构造器的自动定义规则

- :one:在我们**没有定义**`无参构造器`以及`有参构造器`的情况下,我们的`Java`**会自动为我们的类创建**出一个`无参构造器`
- :two:在我们**定义了**`无参构造器`或者`有参构造器`的情况下,`Java`便**不再会为我们的类自动建立**`无参构造器`

## **`Java`属性赋值的先后顺序**

### 属性赋值的五大途径

- **默认初始化**
- **显示初始化**
- **构造器赋值**
- **外部类实例`.`方法访问属性并赋值**
- **代码块赋值**

****

### 先后顺序(从上到下越拍下方赋值越后)

- :one:**默认初始化**

  - `int a`

- :two:**显式初始化**

  - ```java
    int a;
    a = 10;
    //或
    int a = 10;
    ```

- :two:**代码块赋值**

  - `{a = 30;}`

- :three:**构造器赋值**

- :four:**外部类实例`.`方法访问属性并赋值**

  - ```java
    person.setAge(52);
    ```

- **注意**:显式的初始化与代码块赋值是平级的,**谁声明的位置在前谁先执行**

****

## `this`关键字的使用

> - **`Java`的`this`关键字基本与我们的`C++`中的`this`关键字作用相同**
>
> - **`this`指针实际上指向的位置就是调用该方法的类实例在内存栈区中的存储位置**
>
> **`this`的使用**
>
> - **调用方法**:`this.方法名(实际参数)`
> - **调用属性**:`this.属性名`
> - **调用构造器**:`this(实际参数)`
>
> **注意事项**
>
> - 通过`this`调用构造器**只能在当前类的构造器的首行才合法**

****

### **使用范围**

- `this`关键字使用在**类方法的内部**
- `this`关键字还可以使用在**类的构造器内部**

****

### **作用**

- :one:`this`关键字实际上是对于我们的某一个类实例的引用.我们可以**通过`this.属性,this.方法`访问某个类实例的属性以及方法**
- :two:`this`关键字**一般是用来区分方法内部的局部变量与我们的类属性,类方法的**
  - 如我们当前类中有一个名称为`name`的属性,而该类的`setName`方法中也有一个名为`name`的局部变量.我们要使用`setName`对我们的类的`name`属性进行赋值,那么就有`name=name`,这显然是不行的,因此我们就可以通过`this.name=name`来唯一标识前一个`name`是我们类实例的属性,而不是局部变量
- :three:`this`关键字还可以用于辅助我们进行**链式调用**
  - 我们知道访问一个类实例的属性或方法的方式为`类实例名.属性|类实例名.方法`
  - 而我们的`this`正好就等价于我们的类实例,因此我们可以让我们的类中的方法的返回值为`return this`
  - 在这样的情况下,我们有`A.方法1().方法2()`中`A.方法1()`就**通过`this`指针变为了`A`,因此我们就可以继续使用`.`方法来链式调用类实例`A`的属性与方法**

****

### **注意事项**

- `this`指针是由我们的`Java`程序**自动维护**的,对于多个同一个类下的类实例`A,B,C`.假设我们的`方法1`中使用了`this`指针,那么当我**们使用`A.方法1()`**时`方法1`中的`this`指针**指向的地址就是`A`实例的地址**,当**使用`B.方法1()`**时,`方法1`中的`this`指针**指向的地址就是`B`实例的地址**

****

### **额外扩展:通过`this`指针调用构造器**

> **`this(传入构造器的参数)`**
>
> **注意**
>
> - :one:在调用构造器时应该注意避免**构造器中调用构造器自己**,从而**导致构造器的递归调用,无法终止**
> - :two:如果一个类中**定义了`N`个构造器**,那么该类**最多只能有`N-1`个构造器**中**使用`this()`调用构造器**
> - :three:**只有在**构造器中**才可以使用`this()`的方式调用构造器**,在**普通的类方法中`this()`是不可用的**
> - :four:在任何构造器中,如果要用`this()`调用构造器,都**必须在该构造器的首行进行`this()`调用**
> - :five:由:four:我们知道,一个构造器最多只能使用`this()`调用**有且只有一个其他的构造器**

- ```java
  public class test{
  	public test(构造器参数){
          构造器语句体
      };
      public static void demo(){
          //在这里就完成了对于构造器的调用
          this(传入构造器的实际参数);
      };
  }
  ```

****

## `package`与`import`的使用

### `package`

> **作用**
>
> - **`package`**用于我们的`.java`文件的**首行**,用于**声明**我们当前`.java`文件中定义的`类,接口`等**所属的包**
>   - `package mytest.atguigu.tl`
>
> **包名的特性**
>
> - **每一个`.`标识一层目录**
>   - :one:例如,我们**创建了一个包`mytest.atguigu.tl`**,那么就有我们的`Java`会**创建**一个`mytest`文件夹**,然后**在`mytest`文件夹下**创建**`atguigu`文件夹,**然后**在`atguigu`文件夹下**创建**`tl`文件夹,**然后**我们该包下的`.java`文件就会**存储在`tl`文件夹**中
>   - :two:若我们**又建立了`mytest.TTL`包**,那么就会**在原来的`mytest`文件夹下**与`atguigu`文件夹**同级创建**一个`TTL`文件夹,然后我们该包下的`.java`文件就会**存储在我们的`TTL`文件夹**中
>   - :three:**注意**
>     - 此时我们的包就会发生一些变化`mytest.atguigu.tl`与`mytest.TTL`**两个包就会被拆分**为`atguigu.tl`与`TTL`包,然后这**两个包会从属于一个`mytest`包**
>     - ![image-20220805195153861](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220805195153861.png)
>
> **注意事项**
>
> - **同一个包**下,**不能有**同名的接口,也**不能有**同名的类
> - **不同包**下,**可以有**同名的接口,也**可以有**同名的类

****

### `import`

> **作用**
>
> - `import`用于**导入指定包下的类与接口**到我们当前的`.java`文件中**以供当前文件调用**
> - `import`应**使用于`package`包声明与第一个类定义`之间`的位置**
> - 对于**同一个包下的类与接口**，我们**无需``import``便可使用**

****

#### **使用技巧**

- :one:`import mytest.*`表示导入``mytest``包中的**所有类与接口**
- :two:`import mytest.demo`表示导入`mytest`包中的**`demo`类或接口**
  - 这里`demo`为一个**类或接口的名称**
- :three:`import mytest.submytest`这样的导入是**不被**我们的`Java`所**认可的**,我们**必须保证最后导入的粒度为`类或接口`,而非包`package`**
  - 这里`submytest`为一个**包的名称**
- :four:对于**`java.lang`包下**的所有类的使用,我们**无需导入**,因为该包中的为`Java`的核心类,`Java`会默认为我们导入
- :five:对于**当前`.java`文件中**定义的类与接口,我们**无需导入即可使用**
- :six:对于``import``导入的类与接口,我们可以在当前`.java`文件中直接用`类名,接口名`来使用,无需与`Python`一样还是要用如`matplotlib.pyplot`的方式使用
- :seven:如果我们当前`.java`文件中**使用了两个不同包下的同名类或接口**,那么我们**不能使用**`import`**导入全部这两个类**,而**只能`导入`其中一个**,而**另一个则必须通过`包名.类名`的方式使用**(不这样做则会**引发同名类的二义性**问题,`Java`**编译器会报错**)

****

#### **注意事项**

- :one:我们**也可以不导入类**,而**直接在我们程序中使用`包名.类名`的方式来进行其他包中类的调用**,只不过这样会导致我们的程序**废话过多,可读性变低**
- :two:==我们的`mytest.*`是只**能导入`mytest`包下的`类与接口`**的,但是**对于`mytest`包下的子包中的类与接口是不会被导入的**==

#### **`import static`**

- 其作用为**导入指定包下**的指定类与接口下的**指定静态的属性或方法**
- `import static mytest.demo.*`:导入`mytest`包下的`demo`类中的所有**静态属性与方法**

****

## **`Java`类的继承性**

> **继承的实现**
>
> `Java`中的继承要**利用`extends`关键字**
>
> ```java
> //创建Students类,并继承Person类
> public class Students extends Person{}
> ```
>
> **继承的优点**
>
> - :one:减少了代码的冗余,提高了代码复用性
> - :two:为功能的扩展提供了便利
> - :three:为多态的使用构建了前提
>
> **注意事项**
>
> - 子类中还可以继续**定义属于自己**`的属性与方法`

****

### **子类`能且只能`继承到的结构**

> - `private,public,protected,缺省`被**四种权限中任何一种修饰的都会被继承**,即**所有的`属性,方法,构造器都会被继承`**
>
> - 当然**继承是不会改变其权限**的,**继承之前**在父类中**是`private`的**,那么**继承后**在子类中其也**照样是`private`的**

- :one:父类中定义的**`方法`**
- :two:父类中定义的**能够被继承的`属性`**

- :three:父类中定义的**能被继承的`构造器`**

****

### `Java`中继承的强制性规则

> - 由于`Java`中的这些规则,`Java`中便**不再具有**`C++`中由于一个子类继承多个父类导致的**菱形继承问题**

- :one:**一个子类只允许继承唯一的一个父类**
- **:two:一个父类可以同时被多个子类继承**
- **:three:继承了某个父类的子类可以被作为父类被其他的类继承**
- :four:**子类直接继承的父类称为`直接父类`,通过父类继承的类称为`间接父类`**
- **:five:子类可以继承得到`直接父类`以及`间接父类`中定义的`所有的属性,方法,构造器`**
- ![image-20220806145619430](F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220806145619430.png)

****

### `Java`继承的问题

- :one:**`Object`类**
  - 在`Java`中任何一个类**都会默认直接或间接地继承我们的`Object`类**,即便我们没有自己指定去继承,`Java`编译器也会默认为我们继承
    - 若类**没有继承**任何类,那么`Java`编译器会默认为其**自动继承`Object`类**
    - 若**类继承**了其他的类,那么`Java`编译器**不会为其自动继承`Object`类**,但其继承的类也**会直接或间接地继承`Object`类**,所以任何类总会直接或间接地继承`Object`类

- :two:**继承的就近原则**
  - 由于一个类可以获取到`直接父类`以及`间接父类`的`所有的属性,方法,构造器`,那么**如果`直接父类`中对`间接父类`的方法进行了`重写`**,那么我们的子类继承到的方法便**是由直接父类重写之后的.**

****

## 方法的重写(`OverRide\OverWrite`)

> **概念**
>
> - 我们的类可以继承其他的类,我们知道此时我们的**子类会拥有父类**中定义的能够被继承的**方法的使用权**,但是如果我们在子类中**又定义**了一个与从父类中继承的到的**方法同名,同形式参数列表的方法**时就会**构成方法的`重写`**
>
> **注意**
>
> - :one:**重载与重写的区分**
>   - 如果子类对中定义了一个与某个从父类继承的**方法同名,但不同形参列表**的方法,那么这是**不构成方法的重写**的,这只是构成了**方法的`重载`**
> - :two:**重写的覆盖特性**
>   - **覆盖特性**意味着**当被覆盖后**,我们`通过子类,子类实例`对**被重写**的方法进行访问就**默认**是访问的`子类重写后`的方法
>   - 当我们的子类**继续被继承时**,**子类的子类继承到**的方法就是**子类重写后的方法**,但**依然会继承**到**父类被重写的方法**
> - :three:**直接父类,间接父类,子类的属性方法共存性**
>   - **前提**:我们知道当我们子类继承了父类,**子类中定义的属性,方法就会与父类的属性与方法共存**
>   - 即便我们对父类的方法进行了重写,**`共存的特性也依然不会改变`**,其**覆盖只是字面意思**,**`实质只是通过修改默认访问的方法为子类重写后的方法而已,被重写的父类依然还是被链接到了我们的子类上`**.
>   - 因此我们可以在子类中**借助`super`关键字**对`直接父类`中**被子类重写的方法进行调用**,当然还可以通过`super.super[.super...]`的方式对`间接父类`中**被重写的方法**进行调用

****

### **重写的规则**

- > :one:子类重写的方法**必须**和父类被重写的方法**具有相同**的`方法名,形式参数类型列表`

  - 若**违反会发生重载,而非重写**

- > :two:子类重写的方法的返回值的数据类型**不能大于**父类被重写的方法的返回值类型

  - 若**违反则直接报错**

  - 父类`void`,则子类也必须为`void`
  - 父类为`A类`类型,则子类必须为`A类`或`A类子类`类型
  - 父类为`基本数据类型`,则子类必须为**相同的**`基本数据类型`

- > :three:子类重写的方法的访问权限**不能小于**父类被重写的方法的返回值类型

  - 若**违反会直接报错**

- > :four:子类中**不能重写**父类中声明为`private`的方法

  - 若**违反不会报错**,只不过其**并不会正常地覆盖掉**我们父类的`private`方法**,而是在子类中共存**,当我们的**子类又被继承时**,这两个同名同参数的**方法又会在子类的子类中共存**

- > :five:子类重写的方法抛出的异常**不能大于**父类被重写的方法抛出的异常

  - 若**违反则直接报错**

- > **:six:`static`修饰带来的重写问题**

  - 子类方法不用`static`,但父类被重写的方法用`static`
    - **不支持,直接报错**
  - 子类方法用`static`,但父类被重写的方法不用`static`
    - **不支持,直接报错**
  - 子类方法不用`static`,父类被重写的方法也不用`static`
    - 就是**正常的方法重写**
  - 子类方法用`static`,父类被重写的方法也用`static`
    - **不报错,但`不构成重写`**,`会在子类中共存`,我们依然可以通过`父类名.静态方法`的方式来对父类原本的方法进行访问.只不过在**继承过程中是用重写后的方法进行继承**

****

## 属性的重定义`OverDefine`

> 与方法的重写相同,我们的**子类也可以重新定义并初始化父类中存在的属性**.这一过程我们可以称之为**属性的重定义`OverDefine`**,与重写相同,**重定义具有覆盖的特性**,即**重定义后**,我们在**子类中**通过属性名**默认访问的就是我们子类重定义之后的属性**,如果要**访问直接父类**中对应的属性则可以在子类中**通过`super.属性`的方式进行**

****

## `super`关键字的使用

> **作用**
>
> - `super`关键字用于辅助我们的子类对其直接父类,间接父类中被**重写的方法,构造器**以及**重定义的属性**进行访问
>
> **`super`的实质**
>
> - `super`实际上**与我们的`this`指针类似**,只不过我们的`this`指针指向的是`调用该方法的类实例`**在内存栈区中的存储位置**
> - ==我们的**`super`指针则是指向我们当前类实例对应的类的`直接父类在内存栈区的存储位置`**==
>
> **`super`的使用**
>
> - **调用方法**:`super.方法名(实际参数)`
> - **调用属性**:`super.属性名`
> - **调用构造器**:`super.构造器名(实际参数)`
>
> **注意事项**
>
> - **只有子类构造器的首行**可以使用`super`调用父类构造器
> - 当我们子类构造器的首行**没有使用**`this()`或`super()`调用构造器时,我们的`Java`编译器会**自动**为我们的**子类构造器的首行**添加`super()`来**调用父类的无参构造器**

****

## **`Java`类的多态性**

### 类的多态的概念

> **声明为`直接父类`或`间接父类`的变量指向子类的实例称为`多态`**

- 当我们**创建一个`直接父类`或`间接父类`的实例对象来接收`new出来的子类对象`时**就会发生**多态**

  - ```java
    Person tangling = new Man()//Man是一个继承了Person类的子类
    ```

****

### `Java`类的多态的原理与我们的`C++`类似

> **注意**:只是类似,在`Java`下**不再具有**`C++`中的`虚函数,虚函数表,虚函数指针`这些概念了,取而代之的是,`Java`会自动帮我们在继承时,让父类的方法都认为是`虚函数`进行继承,因此在`Java`中我们**无需使用复杂的`虚`结构就可以让我们可以通过多态变量访问父类被子类重写了的方法时,`访问的是子类重写后的方法`**,但是**缺点也很明显**,在**`C++`中我们如果不使用`虚`结构就可以让我们的多态变量在访问父类被子类重写了的方法时,`访问到是父类的未被重写的方法`,而不是子类重写了之后的方法**,而在`Java`中我们就无法实现,我们**在``Java``中就一定会访问`子类重写后的方法`**

- **前提**
  - 我们知道**对于引用数据类型**,我们声明出来的**变量名实际上是一个指针**,一个**可以接收对应引用数据类型的地址的指针**
- `Person tangling`就在我们的**内存栈区**中创建了一个**可以接收`Person`类实例地址的变量**
- `new Man()`就在我们的**内存堆区**中创建了`Man`类实例的内存空间
- **最终**我们会通过`=`赋值符号将`new Man()`开辟的空间(作为赋值过程而言**就是一个内存地址**)赋值给我们的`tangling`变量进行保存
- **问题**
  - 显然我们的`tangling`变量是一个接收`Person`类实例地址的变量,而不是一个用于接收`Man`类实例地址的变量,**`这样的赋值过程显然会发生强制类型转换子类类型的地址会被强制转换为父类类型的地址`**.**因此此时就发生了用父类的指针指向子类的类实例的问题**

### **多态构建的变量的特性**

- :one:多态变量**调用父类中没有被子类重写的方法或没有被子类重定义的属性**时**调用的为父类中的方法或属性**
- :two:多态变量**调用父类中被子类重写的方法**时**调用的为子类重写后的方法**
- :three:多态变量**`不能调用`父类中没有定义过的方法**,**只能**调用父类**定义过**的方法(**被重写的方法也算定义过的**
- :four:多态变量**调用父类中被子类重定义的属性**时**调用的为父类中的属性,而不是子类重定义后的属性**,因此**属性是不满足多态性的**
- :five:多态变量**调用父类中的子类中有同名的静态的方法以及属性**时,访问的为父类**自己的静态方法或属性**

****

### 多态的应用情景

- 我们现在有一个任务,**需要由一个人来完成**,因此我们就**会声明一个`人`这个类的指针**,然后利用多态的特性我们时可以**通过这个`人`的指针接收`人`类以及`人`类的子类的实例的**.
- 而由于我们只需要一个人来完成我们的任务,因此**完成任务时显然只需要调用`人`类所具备的属性与方法**的,因此**我们的多态很好地实现了这一要求**
- **如果我们没有多态**,那么我们需要一个人来完成任务,而人有`男人,女人,小孩,老人`等等多个类别,**显然我们没有多态就无法通过`人`类的指针指向这些子类的实例**的,因此我们为了完成任务就**必须重载多个方法,分别接收`男人`实例,`女人`实例,`小孩`实例,`老人`实例**,这样就会导致我们的**代码冗余过多,复用率低下**

****

### **注意事项**

- **类的多态是根据动态多态实现**.(即`地址晚绑定`)
  - 在**编译时**我们的多态变量会被我们的`Java`编译器认为是一个**父类实例对象**,因此**在编辑时我们使用`.`方法调用属性或方法实际上会被认为是对父类中没有重写的方法或属性进行调用**.
  - 但是在**实际运行时**,由于我们通过多态变量**接收的是一个子类的实例对象**,因此**其就会按照多态变量的特性进行实际的执行**

****

## `instanceof`关键字的使用

> **基本语法:`x instanceof A`**
>
> - `x`:类实例
> - `A`:类名
>
> **作用**
>
> - 若`x`所属的类是类`A`的**子类**,那么返回值为`False`
> - 若`x`所属的类**正是类`A`或类`A`的父类**,那么返回值为`true`
> - 若`x`所属的类**既不是**类`A`的子类或父类,**也不是**类`A`,那么我们的**编译就会报错**
>
> **注意**
>
> - 这里的所属类型指的是我们的我们在声明变量时,等号右边`new`的数据类型
>   - `Person t = new Man()`:`t`为`Man`类型
>   - `Man t = new LittleMan()`:`t`为`LittleMan`类型

****

## **向下转型与向下转型**

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220807151737895.png" alt="image-20220807151737895" style="zoom: 67%;" />

- :one:我们知道当我们使用`Person test = new Man()`是时发生了**自动向上转型**的,我们的`Java`运行程序将我们`Man`类型的地址自动向上转型为了`Person`类型,这样**才使得我们的`Person`类型的指针`test`可以接收我们`new`的实例地址**
- :two:问题在于对于上面的情况`test`多态变量**只能访问父类自己的属性以及父类定义了的方法,或子类重写后的方法**.为了解决这一问题我们的`Java`提供了强制向下转型
- :three:`(Man)test`就可以**将`Person`类型的`test`指针转换为`Man`类型的指针**,当强制向下转型**完成后**,我们就**可以通过`test`指针访问到我们子类的属性以及子类的方法.**
- :four:==**实际上当强制向下转型完成后我们就可以把`test`指针当作由`Man test = new Man()`创建出来的指针使用,两者的特性完全相同**==

**注意**

- :one:**自动向上转型是可行的**,当然**也意味着我们在`Java`程序中还可以通过`(Person)test`将`Man`类型的`test`指针强制向上转型**为我们的`Person`类型,此时我们的`test`指针**也是属于一个多态变量**
- :two:考虑这样的情况,有三个类`A,B,C`,`A为B的父类`,`B为C的父类`.那么我们有
  - 类`A`的指针可以强制向下转型为`类B,C`的指针,类`B`的指针可以强制向下转型为`类C`的指针
  - 类`C`的指针可以强制向上转型为`类A,B`的指针,类`B`的指针可以强制向上转型为`类A`的指针
- **:three:由:two:我们必须明确下面的规则**,如果**不满足**下面的规则,**两个不相关的类之间我们绝对不要去对他们做相互的转型**
  - 如果要将`x`**强制向下转型**为`y`,则**必须**保证`x`为`y`的直接或间接父类
  - 如果要将`x`**强制向上转型**为`y`,则**必须**保证`y`为`x`的直接或间接父类

## **`Object类`与`包装类`的使用**

> **`Object`类**
>
> - 
>
> **包装类`Wrapper`**
>
> - 

****

### `Object类`

> **特性**
>
> - :one:`Object`类是我们`Java`自带的**内置类**
>
> - :two:`Obejct`类是任何一个类的**根类**.
>
> - :three:如果一个类没有显式地继承其他类,那么`Java`编译器会为我们的这个类自动继承`Object`类.
>
> - :four:当然如果显示地继承了其他的类,就不会再自动继承`Object`类,但这并不影响其一定会把`Object`类作为间接父类
>   - **原因与我们的子类构造器无论如何最终都会调用父类的构造器的原因道理相同**
> - :five:`Object`类中没有属性,`Object`类只有一个空参构造器,`Object`类定义了大量的方法

#### 常用方法

- `protected clone()`:将调用该方法的类实例复制一份,并**以复制出来的类实例的指针作为方法的返回值** 

- `equals()`:传入一个类实例,其作用为**比较调用该方法的类实例是否与我们传入的类实例相等**

  - ```java
    return (this == obj);
    ```

- `protected finalize()`:**解构器**,当我们的类实例需要被作为垃圾回收时,`Java`系统会自动调用该方法

- `getClass()`:返回调用该方法的类实例的类的**类型**

- `hashCode()`:

- `notify()`:

- `notifyAll()`:

- `toString()`:

  - ```java
    public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
    ```

- `wait()`:

#### **`==`与`equals()`的区别**

- 前者**既可以用于`基本数据类型`又可以用于`引用数据类型`**,后者**只能用于`引用数据类型`**
- 前者比较两个引用数据类型是否相等是**直接比较它们的地址是否相同**,而后者则是**比较两个类实例`是否同一个类`,`是否所有属性都相等`**
- **注意**:`equals`**必须**要在我们的`Object`类的子类中被**重写**,**才能正确地实现子类的相等比较**,如果子类**没有重写**`equals`方法,那么`子类实例.equals(其他实例)`**的效果与`子类实例==其他实例`相同**
  - 在`Object`类中`equals`的定义与`==`对于引用数据类型的比较是效果相同的

****

### `包装类Wrapper`

> **概念**
>
> - **包装类即`Java`内置的以面向对象思想实现的八大基本数据类型的引用数据类型.**
>
> <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220807180532360.png" alt="image-20220807180532360" style="zoom:67%;" />

#### 基本数据类型,包装类`Wrapper`,`String`的相互转换

> **注意事项**
>
> - 任何一个包装类都**只定义有形参为`String`或其对应的基本数据类型**的`构造器`
> - 
>
> <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220807181134897.png" alt="image-20220807181134897" style="zoom: 67%;" />

- :one:**基本数据类型``->``包装类**

  - 调用包装类的可以接收其对应的基本数据类型的形参的构造器

    ```java
    public Integer(int value) {
            this.value = value;
        }
    ```

- :two:**包装类`->`基本数据类型**

  - 调用包装类的`xxxValue()`方法

    ```java
    //举例
    	//Integer包装类,其中value为Integer类的一个实例,会在构造器中被赋值为我们给出的数值
    public float floatValue() {
            return (float)value;
        };
    public double doubleValue() {
            return (double)value;
        };
    public int intValue() {
            return value;
        }
    ```

- **:three:基本数据类型`->` `String`**

  - 调用`String`类的`ValueOf()`方法

    ```java
    public static String valueOf(Object obj) {
            return (obj == null) ? "null" : obj.toString();
        };
    
    public static String valueOf(char[] data) {
            return new String(data);
        };
    
    public static String valueOf(char[] data, int offset, int count) {
            return new String(data, offset, count);
        };
    
    public static String valueOf(boolean b) {
        return b ? "true" : "false";
    	};
    
    public static String valueOf(int i) {
            return Integer.toString(i);
        };
    ```

- **:four:`String` `->`基本数据类型**

  - 调用要转换到的基础数据类型对应的包装类的`parseXXX()`**静态方法**

    ```java
    //以String转int类型为例
    public static int parseInt(String s) throws NumberFormatException {
            return parseInt(s,10);
        };
    public static int parseInt(String s, int radix)
                    throws NumberFormatException
        {
            /*
             * WARNING: This method may be invoked early during VM initialization
             * before IntegerCache is initialized. Care must be taken to not use
             * the valueOf method.
             */
    
            if (s == null) {
                throw new NumberFormatException("Cannot parse null string");
            }
    
            if (radix < Character.MIN_RADIX) {
                throw new NumberFormatException("radix " + radix +
                                                " less than Character.MIN_RADIX");
            }
    
            if (radix > Character.MAX_RADIX) {
                throw new NumberFormatException("radix " + radix +
                                                " greater than Character.MAX_RADIX");
            }
    
            boolean negative = false;
            int i = 0, len = s.length();
            int limit = -Integer.MAX_VALUE;
    
            if (len > 0) {
                char firstChar = s.charAt(0);
                if (firstChar < '0') { // Possible leading "+" or "-"
                    if (firstChar == '-') {
                        negative = true;
                        limit = Integer.MIN_VALUE;
                    } else if (firstChar != '+') {
                        throw NumberFormatException.forInputString(s, radix);
                    }
    
                    if (len == 1) { // Cannot have lone "+" or "-"
                        throw NumberFormatException.forInputString(s, radix);
                    }
                    i++;
                }
                int multmin = limit / radix;
                int result = 0;
                while (i < len) {
                    // Accumulating negatively avoids surprises near MAX_VALUE
                    int digit = Character.digit(s.charAt(i++), radix);
                    if (digit < 0 || result < multmin) {
                        throw NumberFormatException.forInputString(s, radix);
                    }
                    result *= radix;
                    if (result < limit + digit) {
                        throw NumberFormatException.forInputString(s, radix);
                    }
                    result -= digit;
                }
                return negative ? result : -result;
            } else {
                throw NumberFormatException.forInputString(s, radix);
            }
        }
    ```

- **:five:包装类`->` `String`**

  - 调用包装类的`toString()`方法

    ```java
    public String toString() {
            return toString(value);
        }
    
    public static String toString(int i) {
            int size = stringSize(i);
            if (COMPACT_STRINGS) {
                byte[] buf = new byte[size];
                getChars(i, size, buf);
                return new String(buf, LATIN1);
            } else {
                byte[] buf = new byte[size * 2];
                StringUTF16.getChars(i, size, buf);
                return new String(buf, UTF16);
            }
        }
    ```

- **:six:`String` `->`包装类**

  - 调用包装类可以接收`String`类型的构造器

    ```java
    public Integer(String s) throws NumberFormatException {
            this.value = parseInt(s, 10);
        }
    ```

#### **自动装箱与自动拆箱**

> **作用**
>
> - 用于**实现基本数据类型与包装类之间的自动类型转换**
>
>   ```java
>   int a = 10;
>   Integer b = a;//此时a会自动装箱为我们的Integer包装类并返回给b
>                 
>   Integer b = new Integer(10);
>   int a = b//此时b会自动拆箱为我们的int数据类型并返回给a
>   ```

## `static`关键字的使用

> `static`关键字可以用于修饰`属性`,`方法`,`代码块`,`内部类`

****

### 静态修饰符`static`的作用

- :one:所有的实例化对象**共享一个静态成员变量**,任何一个实例化对象**修改了静态成员变量的取值**,那么任何其他实例化对象在访问该静态成员变量时,**就得到的是修改后的值**
- :two:在**编译阶段**静态成员变量以及静态成员函数便**分配好了地址在内存方法区静态池相对于其所属类在静态池拥有的内存的首地址的偏移量,当程序开始运行,类被加载到内存上时,我们的静态变量,静态方法就会被同步加载到内存方法区的静态池**(而一般的成员变量是**在类实例化时才会获得内存分配**,并且**实例化多个类对象就会有多个`存储在不同内存地址`的从属于不同类对象的成员变量)**
- :three:静态成员函数**只能访问静态变量与静态方法**
- :four:==静态的方法可以直接通过`类名.静态方法名()`的方式直接访问,静态属性也同理.**无需借助实例化的类**==
- :five:==**静态的`方法`与`属性`在程序运行时`其所在的类第一次被使用到时`创建并存储到我们的`内存方法区的静态池`**==
- :six:对静态成员属性的修改会**一直作用到我们的`Java`程序运行结束**,然后下一次我们运行该`Java`程序时,静态属性的取值**又会按照我们类中的定义进行**.**不会受到上一次`Java`程序运行时对于其的修改操作的影响**

****

### 静态修饰符`static`的使用

- `属性`

  ```java
  static int country = "中国"
  ```

- `方法`

  ```java
  public static void test(){}
  ```

- `代码块`

- `内部类`

****

### `静态`与`非静态`的特性

- 通过类名**在权限允许的情况下**我们**可以**访问类的`静态变量与静态方法`,**但不能**访问任何`非静态`结构
- 通过类实例,**在权限允许的情况下**我们**既可以**访问`静态`结构**又可以**访问`非静态`结构
- `静态`的方法**只能**访问`静态`的**属性与方法**,而`非静态`的方法在权限允许的情况下**既可以**访问`静态`结构**又可以**访问`非静态`结构

****

### 静态变量的内存结构

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220808125318868.png" alt="image-20220808125318868" style="zoom:67%;" />

****

### 什么时候将方法与属性设置为`静态`?

- 如果一个属性可以**被所有类实例共享**,并且**任意时刻下**不同类实例中该属性的**值总会相同**时.
- 用于**操作静态属性**的方法可以创建为`静态的`
- **工具类中的方法**一般创建为`静态的`,如`Math类,Arrays类等`

## `main()`方法的语法以及含义

- `main`方法是被作为我们的程序入口的,当我们用`Java.exe 类名`时,`Java`就会在我们的类中自动找到`main()`方法,然后运行`main()`方法

- `main`方法是一个`public`,`static`,且没有返回值`void`的函数

- `main`方法可以接收字符串数组作为参数`String[] args`

  - ```shell
    java.exe 类名 参数1 参数2 参数3...
    ```

## 代码块

> **概念**
>
> - **代码块**与`属性,方法,构造器`一样也**是`Java`类的成员之一**
> - **代码块**只有**`static`修饰与无修饰两种**
>
> **基本语法**
>
> - ```java
>   //无修饰
>   {代码}
>   //static修饰
>   static{代码}
>   ```
>
> **作用**
>
> - 一般用于**初始化我们的类以及类的实例化对象**

****

### 静态代码块与非静态代码块的区别

#### 静态代码块

- :one:可以有如`System.out.println()`这样的**输出语句**
- :two:静态代码块**会**在`Java`程序运行时**随着其所在的类加载到内存**中**自动执行**
- :three:由:two:我们知道静态代码块只会在**程序运行开始**时执行**有且仅有一次**
- :four:静态代码块可以**定义多个**,并且**执行顺序为按照声明的先后顺序**
- :five:静态代码块中对于**本类**而言**`只能`其调用`静态`的方法与属性,即便是`private`的也可以**,对于**其他类**而言则可以按照编程逻辑正常使用(当然我们**必须保证**我们的**类在加载时**该其他类**已经加载完毕**了)

#### 非静态代码块

- :one:可以有如`System.out.println()`这样的**输出语句**
- :two:非静态代码块**不会**在`Java`程序运行时**随着其所在的类加载到内存**中**自动执行**
- :three:非静态代码块会在`Java`程序运行时**随着其所在的类被实例化为类对象自动执行**,该类**每实例化一次该代码块就会执行一次**
- :four:由:three:我们知道非静态代码块在`Java`程序运行过程中可以**执行多次**
- :five:非静态代码块可以**定义多个**,并且**执行顺序为按照声明的先后顺序**
- :six:非静态代码块中可以对于**本类**而言可以调用**所有`静态,非静态`的方法与属性**,即便是`private`的,对于其他类而言与静态代码块相同**(但没有静态代码块那样的要求**,因为静态代码块被调用时,**所有的类一定是已经被加载了**的)

****

### 代码块与构造器的关系

****

### **代码块的是不参与继承的**

## `final`关键字的使用

> - `final`关键字可以用于修饰`类,类方法,变量`
>   - **注意**:`类属性`,`局部变量`等都是变量

****

### 修饰类

- 使用`final`修饰的类是**不能被其他的类所继承**的,即**不再能够具备子类**

  ```java
  final class TestClass{}
  ```

- `String`,``System``,``StirngBuffer``类都是`final`修饰的

****

### 修饰方法

- 使用`final`修饰的方法是**不能被该类的子类所重写的,如果重写就会直接报错**

  ```java
  final public void testFunc(){}
  ```

- `Object.getClass()`方法就是**不可重写的**

****

### 修饰变量

- :one:使用`final`修饰的变量是**在`第一次`给他`赋值`后便无法再被改变其值的,如果修改就会直接报错**,类似于`C++`的`const`

- :two:我们可以称`final`修饰的变量为**常量**,(变量被转化为了常量)

  ```java
  //例1
  final int PI = 3.1415926;
  //例2
  final int PI;
  PI = 3.1415926;
  ```

- :three:若一个变量**被声明为`静态的`**，那么我们**必须**在**声明时就对其进行`显式初始化`**，否则**直接编译报错**

****

#### `final` `修饰的类属性`

> **只支持**下面**三种初始化方法**

- :one:在类中**显式初始化**
- :two:在类的**代码块**中初始化
  - 若**类属性为`static`修饰的,那么若我们对其使用`final`关键字后不同时对其进行显式初始化**,那么就会导致问题的发生,其原因如下
    - 非静态的代码块会在每一次类实例化时自动执行,而**静态的`final`类属性在整个类的周期内都只能初始化一次**,因此如果在非静态代码块中对其进行初始化就**会导致第二次类实例化时发生修改常量的错误**,因此我们的`Java`为了避免这一问题便直接让我们`static`的类属性必须在使用`final`的情况下**声明的同时就要初始化**
- :three:在类的**构造器**中初始化
  - 若**类属性为`static`修饰的,那么若我们对其使用`final`关键字后不同时对其进行显式初始化**,那么就会导致问题的发生,其原因与**`代码块一致`**
- :heart:**为什么不能在类的方法内赋值?**
  - :one:方法可以调用多次,如果**方法内对常量赋值**,就**必然导致方法的第二次调用会报错**,就**破坏了方法的可多次调用性.**因此`Java`为了避免这一问题,

****

#### `final` `修饰的局部变量`

> **只支持**下面**两种初始化方法**

- 在方法中**显示初始化**
- 作为**形式参数**在**接收实际参数时初始化**

****

## 抽象类与抽象方法(`abstract`)

> **抽象类**
>
> - 抽象类一般是**作为一个规范**存在的,其只**用于继承**,并且**不会也不能被实例化**.例如:人是一个抽象类,其中规范地定义了人的基本属性与基本方法.无论是`学生,老师,警察`等等这些身份的类,**都需要`直接或间接`地继承人这个抽象类**
>
> **抽象方法**
>
> - 抽象方法也是**作为一个规范**存在的,其只用于**引导我们的子类对其进行重写**,**抽象方法是无法被调用的**

****

### ==**`abstract`关键字`可用且只可用`于`类,类方法`**==

****

### 抽象类与抽象方法的特性

> - **若一个类`A`继承的直接或间接父类中有一个或以上的抽象类,且这些抽象类中的方法`没有全部`被类`A`的任何一个直接或间接父类重写,那么类`A` `必须`重写所有这些没有被重写过的`抽象方法`才能被实例化,`如果没有重写`所有的抽象方法,那么我们的类`A` `必须`声明为`abstract`抽象类,否则直接报错**

#### 抽象类

- :one:抽象类是**无法被实例化的**
- :two:抽象类中**可以定义普通方法,包括静态的方法**
- :three:抽象类中的**静态方法以及静态属性**是**可以**直接通过`抽象类.静态方法名()|抽象类.静态属性名`调用的
- :four:抽象类与普通的类一样**`可以且必须`具备构造器**,只不过其构造器是**用于保证子类实例化时对于父类构造器的调用能够正常进行**,而**不是用于实例化**
- :five:对于类而言**`final`与`abstract`关键字不能同时使用**,原因在于`final`的类是无法被继承的
- :six:抽象类与普通类一样,**一个抽象类**可以被**多个抽象类,普通类**继承,但**一个抽象类只能继承一个普通类或抽象类**

#### 抽象方法

- :one:抽象方法**无法被调用**,且**不能写`{}`**
- :two:**只有抽象类中能够定义抽象方法**,原因在于抽象的方法必须被子类重写,子类才能不声明为`abstract`
- :three:**抽象类中可以不定义抽象方法**
- :four:对于方法而言**`static`与`abstract`关键字不能同时使用**.静态方法一定不为抽象方法,抽象方法也一定不为静态方法.原因在于`static`的方法是无法被子类重写的
- :five:对于方法而言**`private`与`abstract`关键字不能同时使用**.原因在于私有的方法是无法被子类重写的
- :six:对于方法而言**`final`与`abstract`关键字不能同时使用**.原因在于`final`的方法是无法被子类重写的
- :seven:==由于抽象方法是没有方法体的,因此**假如抽象类继承了抽象类**,且两个类中**有同名同形参列表的抽象方法**,那么是**不会构成重写**的.只不过我们后续**非抽象类继承**时,**重写就会`同时`把这两个抽象方法都重写了**==

****

### 抽象类与抽象方法的应用场景

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220809234802984.png" alt="image-20220809234802984" style="zoom:67%;" />

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220809234854197.png" alt="image-20220809234854197" style="zoom:67%;" />

****

### 抽象类与类的多态

> - 虽然**抽象类不能实例化**,但是抽象类是**具备通过`抽象类名 指针名`的方式建立出抽象类类型的指针的权限**的.
>
> - 因此对于抽象类而言,**我们一样可以利用`向上转型`实现以抽象类的指针,访问抽象类的子类的类实例的操作**
> - 并且**我们还可以通过`强制向下转型`让我们抽象类类型的指针变为其子类类型的指针**

****

### 抽象类的`匿名子类`

> **本质**
>
> - 在实例化之前通过`{}`给我们的`抽象类`**临时定义**了一个**匿名的`子类`**,然后实例化时**虽然`new`的是我们的`抽象类`但`实际`上`Java`程序实例化的是那个临时定义的匿名子类**

#### 要求

- :one:**必须**重写抽象类及其直接或间接父类的**所有抽象方法**
- :two:由于是临时定义匿名子类,因此我们**不仅可以**重写`抽象方法`与`非抽象方法`,还**`可以且只可以`**定义子类自己的`非静态类方法,非静态类属性,非静态代码块, 非静态内部类`,

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220810142403951.png" alt="image-20220810142403951" style="zoom:67%;" />

****

## `interface`接口关键字的使用

> **概念**
>
> - `interface`是一个与`class`同**级别的关键字**,类与接口为同级结构
> - 我们知道`class`的类的继承是只能进行单继承的,即一个类只能最多有一个直接父类,而`interface`则不同,一个类一个
>
> **基本语法**
>
> ```java
> interface 接口名{语句体}
> ```

****

### 接口的继承

- **类继承接口**

  ```java
  class 类名 [extends 直接父类名] [implement 接口1,接口2...]{}
  ```

- **接口继承接口**

  ```java
  interface 接口名 [extends 接口1,接口2...]
  ```

****

### 接口中能定义的结构

> **接口中`可以且只可以`定义如下的结构**

- :one:全局常量`public static final`
- :two:公共抽象方法`public abstract`
- :three:公共静态方法`public static`
  - **接口中的静态方法**是**不会被继承**的,只能通过`接口名.静态方法名()`方式调用

- :four:公共默认方法`public default`
  - 接口中的`默认方法`**可以被继承**,且默认方法是可以被**`子类(或子接口)`**重写的.
  - **类优先原则**
    - 如果**直接父类与直接父接口**中定义了`同名同参数`的方法,并且**子类没有进行重写**,那么`Java`**默认**调**直接父类中的那个方法,而`不是`调用直接父接口中**的


****

### 接口的特性

- 由于对于属性而言**只能定义全局常量**,因此定义属性时`public static final`**可以直接省略**
- 接口是无法实例化的,`Java`开发中需要通过`implement`关键字让我们的**类来继承我们的接口的方式来使用接口.**
- 若一个类通过`implement`继承了我们的接口,那么其**必须重写其继承的接口中定义的所有的抽象方法,该类才能实例化,否则该类必须被声明为`abstract`抽象类**
- **一个类**可以继承**多个接口**,**一个接口**可以被**多个类继承**
- **接口也可以继承接口**,且**一个接口**可以继承**多个接口**,一**个接口**可以被**多个接口继承**

****

### 接口会引发菱形继承问题?

> **问题描述1**
>
> - 接口`B,C`都继承接口`A`,然后接口`D`继承接口`B,C`
>
> **问题1**
>
> - 接口`B,C`都继承了接口`A`,那么接口`D`继承了接口`B,C`后是否会重复地存储有接口`A`的``属性,方法等``呢
> - **答案是`Java`会为我们自动处理这一问题,避免重复继承**
>
> **问题2`直接报错`**
>
> - 若接口`B,C`中都定义了一个同名同形参列表的`公共静态常量`,且接口`A`中也定义了一个同样的.那么当我们调用接口`D`的这个`公共静态变量`时调用的是哪个呢?
> - **对于这个问题,`Java`会以同时存在三个同名的`公共静态变量`而直接报错(`A,B,C`下各一个)**
>
> **问题3**`直接报错`
>
> - 若接口`B,C`中都定义了一个同名同形参列表的`公共静态方法`,且接口`A`中也定义了一个同样的.那么当我们调用接口`D`的这个`公共静态方法`时调用的是哪个呢?
> - 由于`接口`的`公共静态方法`是**无法被继承**的,因此**不存在**我们可以在`D`中调用到该`公共静态方法`
>
> **问题描述2**
>
> - 接口`B,C`都继承接口`A`,然后类`D`继承接口`B,C`
>
> **问题4**`直接报错`
>
> - 若接口`B,C`中都定义了一个同名同形参列表的`公共默认方法`,且接口`A`中也定义了一个同样的.那么当我们调用实例化子类`D`的这个`公共默认方法`时调用的是哪个呢?
> - **对于这个问题,`Java`会以同时存在两个同名的`公共默认方法`而直接报错(`B,C`中各算一个,`A`中的则被`B,C`重写了)**
>
> **问题描述3**
>
> - 接口`B`与类`C`都继承接口`A`,然后类`D`继承`B,C`
>
> **问题5**
>
> - 若接口`B`定义了一个`公共默认方法`,类`C`中则定义了一个与接口`B`定义的`公共默认方法`**同名同形参列表**的`方法`,且接口`A`中也定义了一个同样的.那么当我们调用实例化子类`D`的这个`公共默认方法`时调用的是哪个呢?
> - 对于这个问题,`Java`会调用父类的方法,因为`Java`保证**类优先性**

****

### 接口与接口继承的重写问题

> **前提**
>
> - 从接口中**可以存在的结构角度**我们知道,**只有抽象方法是可以被重写的**

- 由于接口中是不能有普通的方法的,因此**接口继承接口是不会发生任何重写的**,并且由于抽象方法不具备方法体与形参,因此即便**当前接口继承的多个接口中有同名的抽象方法**,也**不会导致**类似于同时存在同名方法而导致的**二义性问题的报错,并且会被我们的的`Java`看作同一个方法,当我们子类重写这个方法时就`会视作这些同名抽象方法全部重写了`**

****

### 接口与类的多态

> - 虽然**接口不能实例化**,但是接口是**具备通过`接口名 指针名`的方式建立出接口类型的指针的权限**的.
>
> - 因此对于接口而言,**我们一样可以利用`向上转型`实现以接口的指针,访问接口的子类的类实例的操作**
> - 并且**我们还可以通过`强制向下转型`让我们接口类型的指针变为其子类类型的指针**

****

### 接口的`匿名子类`

> **本质**
>
> - 在`new`实例化之前通过`{}`给我们的`接口`**临时定义**了一个**匿名的`子类`**,然后实例化时**虽然`new`的是我们的`接口`但`实际`上`Java`程序实例化的是那个临时定义的匿名子类**

#### 要求

- :one:**必须**重写接口及其直接或间接父类的**所有抽象方法**
- :two:由于是临时定义匿名子类,因此我们**不仅可以**重写`抽象方法`与`非抽象方法`,还**`可以且只可以`**定义子类自己的`非静态类方法,非静态类属性,非静态代码块, 非静态内部类`,

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220810192253193.png" alt="image-20220810192253193" style="zoom: 67%;" />

****

## 普通类的匿名子类

## 类的匿名的汇总

### 非匿名类的非匿名对象

```java
Person p = new Man();
Person p = new Person();
```

### 非匿名类的匿名对象

```java
new Person();
new Man();
```

### 匿名类的非匿名对象

```java
Person p = new Man(){
	匿名子类的语句体
}
```

### 匿名类的匿名对象

```java
new Man(){
	匿名子类语句体
}
```

## `普通类`,`抽象类abstract`,`接口interface`同时参与情况下的各种特性

### 继承特性

- :one:普通类与抽象类之间的继承与普通类与普通类之间的继承是**基本一致**的,只不过**如果一个类继承了抽象类,那么其`必须重写抽象类的所有抽象方法`才能声明为普通类,否则必须声明为抽象类**
- :two:对于`接口interface`而言,由于其只有四种结构,且**除`抽象方法`外**其他三种结构**无法重写**,因此我们记住**继承了接口的类必须`重写接口的所有抽象方法`才能声明为普通类,否则必须声明为抽象类**
- :three:然后我们要知道**无论是普通类还是抽象类**最终都是类,因此他们**只能有一个直接父类**.而**接口则不然**,一个接口,一个普通类,一个抽象类都**可以继承多个接口**
- :four:接口可以继承接口,且**接口只能继承接口**
- :five:普通类和抽象类可以**继承`普通类`,`抽象类`以及`接口`**
- :six:**若一个类要同时继承类与接口,必须先`extends`继承类,再`implement`继承接口**

****

### 同时继承了父类与父接口的情况下`指定`对父接口的方法进行调用

> **基本语法**:`父接口名.super.方法名()`

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220811202628807.png" alt="image-20220811202628807" style="zoom: 50%;" />

****

### 类中不可重写的`private`方法,`static`方法,`final`方法在类继承中引发的`二义性`问题

#### 不涉及接口的情况

> **结论**
>
> - `不会导致二义性问题发生`
>
> **原因**
>
> - 在不涉及接口的情况下**是`不会`发生二义性问题的**,因为对于同一个名字的方法，我们的`Java`会**先在子类中找，如果找不到就会在直接父类里面找，如果还找不到就会在直接父类的直接父类中找**。只要找到了一个我们调用的方法，就**不会再继续查找**，因此虽然是不可重写的情况下会导致同名方法共存。但是在**不涉及接口的情况下并不会导致由于`调用同名方法`导致的`二义性`问题**

#### 涉及接口的情况

> **结论**
>
> - `有可能导致二义性问题发生`
>
> **原因**
>
> - 在涉及接口的情况下,由于一个类可以继承多个接口,并且还可以在继承多个接口的同时继承一个直接父类.**因此当我们调用同名的不可重写的方法时,就`有可能`会发生`二义性`问题**.如果通过我们的方法名加形参列表无法找到唯一的一个方法进行调用,那么就会发生`二义性`问题.而当涉及接口时,**各个接口与直接父类是同级别**的,因此可能我们调用的方法在接口中与直接父类中存在有两个及以上,此时我们是**无法通过先搜子类再搜父类的方式来唯一确定一个需要调用的方法的,因为我们的`接口以及直接父类同级`**
>
> **为什么是可能导致?**
>
> - 直接父类与直接父接口中有同名同形参列表方法
>   - 由于类优先原则,因此会使用直接父类中的方法,因此**不会产生二义性**
> - 直接父接口与直接父接口中有同名同形参列表方法
>   - 由于`直接父接口`是同级的,因此**会产生二义性**
> - 直接父接口与间接父接口有同名同形参列表方法
>   - 会优先调用直接父类中的方法,**因此不会产生二义性**

****

### 类中属性同名在继承中引发的`二义性`问题

#### 不涉及接口的情况

> **结论**
>
> - `不会导致二义性问题的发生`
>
> **原因**
>
> - 虽然类属性是不会被重写的,但是与我们的同名方法调用相同,当我们调用一个类属性时,会**首先在我们的子类中搜索,然后在直接父类中搜索,然后再在直接父类的直接父类中搜索**.直到**`第一次`**查到我们要访问的类属性就**不会再继续搜索下去**.因此即便有同名的类属性,也会由于这一工作原理而**避免二义性问题的发生**

#### 涉及接口的情况

> **结论**
>
> - `有可能导致二义性问题的发生`
>
> **原因**
>
> - **原理与同名方法调用相同.**

****

### 类优先原则

****

## **子类的实例化具体流程**

### 最简单的情况

- **首先**会按照我们类中语句的**顺序依次执行**
  - 属性就在**堆区开辟内存空间**
  - **栈区开辟指针**交给我们的实例对象保存
  - **方法**就**获取**到方法区中存储的**各个方法的入口地址交给我们的实例以便调用**
- **然后**就会调用我们的`构造器`

****

### 在不考虑`代码块与接口`的情况下

- :one:首先我们在`java`程序中通过`子类名 子类对象名 = new 子类名(实际参数)`来实例化我们的子类
- :two:然后我们的`Java`编译器就会将该子类继承的直接父类与间接父类的所有**非静态属性**以及该子类自己的**非静态属性**创建出来并存储到我们的**内存堆区**,然后会在我们的**内存栈区**中生成该子类实例,并把该子类实例的**内存堆区**存储地址保存在**内存栈区**的该**子类实例的位置** 
- :three:然后还会将所有的`子类,直接父类,间接父类`中定义的**非静态的方法**在我们的**内存方法区**中创建出来,并**把访问它们的地址交给我们的子类实例**
- :four:然后还会将**内存方法区的静态池**存储的`子类,直接父类,间接父类`的`静态属性,静态方法`的访问地址**交给我们的子类实例**
- :five:然后就会**自动调用**我们的子类的与我们实例化时使用的构造器匹配的**构造器**,然后就会**进入构造器的递归调用**过程,直到**递归到`Object`类的无参构造器**为止才会**停止递归调用**.
- :six:当**递归调用的构造器结束,我们的子类实例就算创建成功**了,就生成了我们需要的子类实例
- <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220806201227231.png" alt="image-20220806201227231" style="zoom: 40%;" /><img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220806195523268.png" alt="image-20220806195523268" style="zoom:60%;" />

****

### 不考虑`接口`的情况下

- :one:首先我们在`java`程序中通过`子类名 子类对象名 = new 子类名(实际参数)`来实例化我们的子类
- :two:==然后我们的`Java`就会将我们**要使用的却没有被加载到内存上的类加载到内存**上,并且加载的时候会按照顺序依次执行`间接父类,直接父类,子类`的**静态代码块**==
- :three:然后我们的`Java`编译器就会**通过构造器的递归调用**将该子类继承的直接父类与间接父类的所有**非静态属性**以及该子类自己的**非静态属性**创建出来并存储到我们的**内存堆区**,然后会在我们的**内存栈区**中生成该子类实例,并把该子类实例的**内存堆区**存储地址保存在**内存栈区**的该**子类实例的位置** 
- :four:之后还会将所有的`子类,直接父类,间接父类`中定义的**非静态的方法**在我们的**内存方法区**中创建出来(**只在第我们程序中`第一次使用到`该类时才会进行这一步，如果`不是第一次`，那么就会直接进行访问地址的交付**),并**把访问它们的地址交给我们的子类实例**
- :five:然后还会将**内存方法区的静态池**存储的`子类,直接父类,间接父类`的`静态属性,静态方法`的访问地址**交给我们的子类实例**
- :six:然后就会从`Object`根源类开始依次执行`间接父类,直接父类,子类`中的对于类属性的**显示初始化语句**
- :seven:==然后就会从`Object`根源类开始依次执行`间接父类,直接父类,子类`中的**非静态代码块**==
- :eight:然后就会**自动调用**我们的子类的与我们实例化时使用的构造器匹配的**构造器**,然后就会**进入构造器的递归调用**过程,直到**递归到`Object`类的无参构造器**为止才会**停止递归调用**.
- :nine:当**递归调用的构造器结束,我们的子类实例就算创建成功**了,就生成了我们需要的子类实例

****

## 类继承的底层原理与`this`,`super`指针

### 不考虑接口的情况下

#### 问题描述

> - 我们知道当我们的子类具有多个父类(直接与间接)时,当我们实例化子类时,子类会具有`自己,直接父类,间接父类`的所有`属性,内部类`,并且`Java`会返回一个访问地址给我们的`Java程序`.而这个访问地址就是我们的`子类实例`的访问地址.
> - 但是我们知道在每一个类中都可以使用`this`与`super`指针,那么对于我们上述的情况`子类,直接父类,间接父类中`的这两个指针是一种什么样的情况呢?

#### 解答

> `this`
>
> - **子类中**,`this`是一个子类类型的指针,其指向我们的子类实例
> - **直接父类中**,`this`是一个直接父类类型的指针,其指向我们的子类实例,可以发生多态
> - **间接父类中**,`this`是一个间接父类类型的指针,其指向我们的子类实例,可以发生多态
>
> `super`
>
> - **前提**
>   - `super`虽然我们称之为指针,但**实质上其不是一个指针**,其只是一个用于告诉我们的`Java`我们后面调**用的这个东西是我当前类的直接父类的东西**.

****

### 考虑接口的情况下

> **接口中是没有`this`有`super`关键字可供使用的**

****

## 内部类

> **概念**
>
> - **内部类即类的定义声明位于`其他类的内部`的类**
> - 内部类可以被**四种权限修饰符,`static`,`final`,`class`,`abstract`修饰**
>
> **内部类的作用**
>
> **内部类的分类**
>
> - **按照定义位置分类**
>
>   - **`成员内部类`**:与类的属性同级
>
>   - **`局部内部类`**:定义在类的**方法内**,**代码块内**,**构造器内**
>
> - **按照类型分类**
>
>   - `静态内部类`
>   - `非静态内部类`
>
> - **特殊**:`匿名内部类`
>
>   ```java
>   //例
>   Person p = new Man(){
>   	类定义语句体
>   ```

### 内部类中可以定义的结构

- **属性**
- **方法**
- **构造器**
- **内部类**
- **代码块**

### 内部类的不同修饰的含义

- 静态内部类
- 非静态内部类
- `final`修饰
- `abstract`修饰

### 内部类情况下的`this`与`super`

#### 成员内部类

#### 局部内部类

### 内部类情况下的同名问题

#### 成员内部类

#### 局部内部类

### 内部类的实例化

#### 在定义该内部类的类内部实例化

#### 在其他类中实例化

### 内部类的继承

### 拓展

- 如果在局部内部类中使用到了该局部内部类所处结构的局部变量,那么**要求这个局部变量必须是`final`的**,否则会直接编译报错

## `native`关键字的使用

## `Java`深拷贝与浅拷贝

# 异常处理

## 异常概述

> **前提**
>
> - 
>

### **概念**

> - 在`Java`中我们的程序**执行过程中发生的不正常的情况**被我们称之为**`异常`**.而我们变成期间的**语法错误与逻辑错误(即我们写的程序不符合我们`Java`的规范.如在`接口中定义代码块,定义构造器`等)**导致的编译失败是**`不算异常`**的
>

### **异常分类**

> - `ERROR`
>   - `JVM`**无法解决**的严重问题
>     - **`JVM`系统运行错误**
>     - **`JVM`栈溢出**
>     - **`JVM`堆溢出等.**
>
>   - ==这种错误我们一般**不处理也难以处理**==
>
> - `Exception`
>   - 由于我们程序内部存在的**设计不完善**导致的程序运行过程中**偶然发生的不正常问题**.
>     - **空指针访问**
>     - **数组下标越界**
>     - **网络连接失败**
>     - **读取不存在的文件**
>
>   - ==这类错误一般我们**可以通过**对程序进行修改或添加错误处理机制来**进行处理==**
>
>

## `Exception`分类

> - **编译时异常**
>   - 即在**`编译`**的时候我们就会发生的异常
> - **运行时异常**
>   - 即只有在**`运行期间才`**会发生的异常

## 异常的体系结构

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220812213440784.png" alt="image-20220812213440784" style="zoom: 67%;" />

## 常见的异常

### 运行时异常

- **`NullPointerException`空指针异常**

  ```java
  String str = null;
  System.out.println(str.charAt(1));
  ```

- **`ArrayIndexOutOfBoundsException`数组角标越界**

  ```java
  int[] a = new int[5];
  System.out.println(a[5]);
  ```

- **`InputMismatchException`输入不匹配**

  ```java
  Scanner scanner = new Scanner(System.in);
  //输入的如果不是int类型,那么就会触发该异常.如输入字符串abc
  int score = scanner.nextInt();
  ```

- **`ArithmeticException`算法逻辑错误**

  ```java
  System.out.println(5/0);
  ```

- **`NumberFormatException`**

  ```java
  String str = "abc";
  int num = Integer.parseInt(str);
  ```

- **`ClassCastException`**

### 编译时异常

- **`FileNotFindException`文件未找到异常**
- **`ClassNotFindException`类未找到异常**
- **`IOException`输入输出异常**

****

## `try catch finally`异常处理机制

> **特性**
>
> - 通过`try`来执行代码,如果发生`Exception`错误,通过`catch`捕获到之后根据我们设定的对不同的`Exception`的处理方案自动处理
>
> **基本原理**
>
> - `Java`程序在运行时如果遇到语句执行异常,就会向用户提示发生了什么类型的异常,并在**程序的异常区生成一个对于异常类型的实例化对象**.正常情况下,当我们的`Java`程序抛出异常后**就会终止程序的继续运行.**
> - ==但是如果我们引入`try catch finally`的机制就能够让我们的程序在**抛出异常后接收抛出的异常类型的实例化对象**进行**处理**,并**使得我们的程序`不被终止,继续运行`**==

****

### **注意事项**

> - :one:**`finally`是可选的**,我们可以不使用而只使用`try catch`结构
> - :two:由于`try catch finally`是使用了`{}`的,因此在`{}`中的代码相对于我们的方法而言是代码块,因此与我们的`C/C++`相同在这个代码块中创建的**所有**`变量,类实例,数组等结构`**都会**在该代码块**运行完毕后被我们的`Java`垃圾回收程序`自动回收`**.**因此我们在代码块中定义的结构出了代码块之后就`无法被调用了`**
>   - ==**注意**:如果是在我们的**方法层级下定义的结构**,代码块**对结构进行了修改**,那么就有如下情况==
>     - 对于没有发生异常的修改操作,那么其**会正确地**作用到我们指定的结构上
>     - 对于发生了异常的修改操作,那么其就**不会作用**到我们指定的结构上(类似于**`MySQL`的回滚**)
> - :three:

****

### 基本语法

- ```java
  try{
  	可能出现异常的代码体
  }
  catch(异常类型1 变量名1){
  	处理异常的方式1
  }
  catch(异常类型2 变量名2){
  	处理异常的方式2
  }
  finally{
      无论发不发生异常最后都会执行的代码体
  }
  ```

****

### 基本流程

#### 无`finally`时

#### 有`finally`时

****

### 多级`catch`使用的异常类型层级关系问题

> **前置知识**
>
> - 我们知道若`类A`与`类B`之间`类A是类B的直接或间接父类`这样的关系,那么他们之间是**可以自动向上转型**的,即`可以用类A类型的指针来接收类B类型的类实例子`
> - **向下转型是`不会自动进行`的,必须我们`手动执行`**
>
> **问题**
>
> - 由前置知识我们可以知道,对于多个`catch`中指定的异常类型,**很可能会存在多个异常类型的指针可以接收我们当前发生的错误的实例化对象**.**因此我们在使用多级`catch`时必须注意这一层级关系**

#### 多级`catch`的基本规则

- 首先**判断第一个**声明的`catch`**是否可以接收**我们的错误的实例化对象
  - 如果可以则由第一个`catch`指示的错误处理方式来处理,处理完毕后直接跳转到`finally`的执行或直接跳出并执行后面的代码
  - 如果不可以进入下一步
- **判断第二个**`catch`**是否可以接收**我们的错误的实例化对象
  - 如果可以则由第二个`catch`指示的错误处理方式来处理,处理完毕后直接跳转到`finally`的执行或直接跳出并执行后面的代码
  - 如果不可以进入下一步
- **依此类推**

#### 具体要求

- 若多级`catch`中指定的异常类型中**存在有两个或以上的异常类型是子父类关系**,那么一定要保证,**子类的`catch`在父类之上**

#### `Exception`的层级关系

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220812213440784.png" alt="image-20220812213440784" style="zoom: 60%;" />

****

### 常用的异常的处理手段

- `getMessage()`异常类的实例方法
- `printStackTrace()`异常类的实例方法

****

## `throws`异常处理机制

> **特性**
>
> - 当遇到错误后,不进行自动处理,而是直接**向我们的用户抛出错误的类型**,期待我们的用户来解决
>
> **基本流程**
>
> - 

### 基本语法

****

## `throw`异常抛出



****

## 用户自定义异常类



****

# 补充知识

## `Java`多态

> **多态的种类**
>
> - 方法的重载是**方法的多态**
> - 类通过继承有**类的多态**
> - 运算符重载是**运算符多态**,其本质也是**方法的多态**
>
> **多态又被分为`动态多态`与`静态多态`两种**
>
> - `静态多态`:在编译阶段就分配好了内存地址.
>   - **方法与运算符的多态**
> - `动态多态`:在实际运行阶段才会分配内存地址.
>   - **类的多态**

### 方法与运算符的多态

> **概念**

### 类的多态

> **概念**

****

## `Java`中形式参数的排序规则

- **:one:普通的形式参数**
- **:two:带默认值的形式参数**
- **:three:可变个数的形式参数**

****

## `JavaBean`

> **若一个`Java`类符合以下条件就可以称其为`JavaBean`**
>
> - 类的**权限修饰**为`public公共的`
> - 有一个**`public`公共的无参的构造函数**(`自定义的或自动生成的都可以`)
> - **有属性**,且对于**每一个属性都有配套方法**
>   - **`set`**:用于**修改或初始化**对应属性的**值**
>   - **`get`**:用于**获取**对应属性的**值**
>
> **`JavaBean`的存在意义**

****

## `UML`类图

> **`UML`类图的作用**
>
> - `UML`类图一般**用于我们的程序编写前的设计过程**,其能够**明确地呈现出我们的一个指定的类`应该具有哪些属性,哪些方法,怎样的构造器`**.**不同`属性,方法,构造器,内部类`应该具备什么样的`权限修饰`,是否需要设置为`静态`等等**
>   - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220804215159135.png" alt="image-20220804215159135" style="zoom:67%;" />

### 权限指代符`+,-,#`

- `-`:表示`private`私有的
- `+`:表示`public`公共的
- `#`:表示`protected`保护的

### 构造器指示符`_`

- 若一个方法**下有下划线**那么其为`构造器`

### 数据类型指定符`:`

- `变量:数据类型`

****

## `Java`单元测试方法

> **作用**
>
> **`Eclipse`**
>
> <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220807175214374.png" alt="image-20220807175214374" style="zoom:67%;" />
>
> **`IDEA`**
>
> - **直接在工程的`src->test->java`目录下构建测试包或测试的`.java`文件即可开始对测试类,单元测试方法的编写.无需像`Eclipse`一般复杂**

****

## `Java`设计模式

> **概念**
>
> - 设计模式是**在大量的实践中总结和理论化之后优选的`代码结构`,`编程风格`,以及`解决问题的思考模式`**.也就是用于解决某些问题的**`套路`**
>
> **经典设计模式**
>
> - **创建型模式**
>   - 工厂方法模式,抽象工厂模式,单例模式,建造者模式,原型模式
> - **结构性模式**
>   - 适配器模式,装饰器模式,代理模式,外观模式,桥接模式,组合模式,享元模式
> - **行为型模式**
>   - 策略模式,模板方法模式,观察者模式,迭代子模式,责任链模式,命令模式,备忘录模式,状态模式,访问者模式,中介者模式,解释器模式

****

### `单例Singleton`设计模式

> <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220808131807739.png" alt="image-20220808131807739" style="zoom:50%;" />

****

#### 特性

- :one:单例设计模式下,我们构建出的类应该在整个`Java`程序**运行过程中有且仅有一个该类的实例化对象**.
- :two:为了确保:one:的成立,在单例设计模式下,该类**应该让所有构造器为`private`的**,从而保证**外界无法通过`new`关键字调用类的构造器创建类实例**
- :three:外界想要**获取**单例设计模式下的**类的实例只能通过调用该类的静态方法**,该静态方法会给我们的`Java`程序返回一个静态的变量,即我们的类实例
- :four:由于静态的方法只能访问类中的静态变量,因此我们的**类实例对应的属性应该是一个静态属性**

****

#### 单例模式的应用场景

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220808151122120.png" alt="image-20220808151122120" style="zoom: 58%;" />

****

#### 饿汉式与懒汉式的区别

- `饿汉式`:类的实例化对象会在我们的`Java`程序的**运行开始阶段就会随着类的加载而创建出来**
- `懒汉式`:类的实例化对象会在我们`Java`程序运行时的**第一次对该类的获取实例化对象的静态方法进行调用时才被创建**

****

#### 饿汉式与懒汉式的优缺点

- `饿汉式`
  - **坏处**:实例化对象即便没有人要用也会创建,增大了内存开销
  - **好处**:线程安全
    - 由于实例化对象**会在我们`Java`程序的进程创建时**就会随着类的加载而实例化出来.因此无论该进程有**多少个线程**,这些线程**无论如何都使用的会`是同一个实例化对象`**
- `懒汉式`
  - **好处**:只有需要使用时才会创建出实例化对象
  - **坏处**:**基础版**是线程不安全的
    - 我们注意到`饿汉式`的写法中有一个`if`判断语句,我们考虑这样一种情况,存在两个线程同时对`getInstance()`方法进行调用,第一个线程**运行完`if`判断语句**就**并发切换**到第二个线程调用,而**此时的`instance`属性显然还是`null`**,因此这样**最终就会导致两个线程分别调用`new`构造出了`两个不同的实例化类对象`.**

****

#### 饿汉式实现

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220808144520311.png" alt="image-20220808144520311" style="zoom: 50%;" />

****

#### 懒汉式实现

##### 基础实现

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220808145523675.png" alt="image-20220808145523675" style="zoom: 50%;" />

##### 改进版实现

****

### `MVC`设计模式

> **`MVC`设计模式即将我们的`Java`程序设计为如下三部分**
>
> - **:one:`Model`模型层**
>   - 对数据进行各种操作,处理
> - **:two:`Controller`控制层**
>   - 参与用户交互
> - **:three:`View`视图层**
>   - 将处理好的数据合理地呈现给用户
> - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220805195636203.png" alt="image-20220805195636203" style="zoom:67%;" />
> - <img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220805195914053.png" alt="image-20220805195914053" style="zoom: 67%;" />

****

### 模板方法设计模式

<img src="F:\A_Java_DataBase_Study_FIle\Java\Java基础知识.assets\image-20220810001905215.png" alt="image-20220810001905215" style="zoom:67%;" />

****

### 代理设计模式

> **基本概念**
>
> - 代理模式即通过**构建一个代理的类**,来**实现我们原本的类需要完成的一些操作**,从而使得原本的类中的**代码简洁,高可读,高可扩展.**
>
> **应用场景**
>
> <img src="https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2" alt="image-20220811155651508" style="zoom:63%;" />
>
> **实例1**
>
> - 每一个人都有吃饭的能力，吃饭就相当于每一个人的基础能力，也就是`Person`类的基础方法.但是呢在不同的地区,不同的国家吃饭的流程是不同的,因此我们可以**定义一个代理类**,在这个代理类中定义一个吃饭的方法,**这个方法呢将吃饭之前的额外流程做完之后能调用`Person`类的吃饭的方法**.
> - 这样的**好处就在于**我们可以让核心类中的方法仅**实现核心的主体功能**,而**更为复杂的其他流程交由代理类完成**.极大地**提高了我们核心类代码的可读性,可扩展性.**
>
> **实例2**
>
> - 我们知道,现在的明星艺人大多都有经纪人,**经纪人的职责**在于为明星艺人规划行程,与其他人谈合作,为明星艺人安排抛头露面的机会.而**明星的任务**则为保持姣好的面貌,良好的演技,动听的歌喉等技能即可,**无需操心那些繁杂的琐事**,能够**将全部的精力投入到对自己的提升当中**.而**这里的`经纪人`就相当于我们的`代理类`,而`明星`就相当于我们的`被代理类`.**

```java
package Study;
class Person{
    public void eat(){
        System.out.println("人吃饭");
    }
}
class ProxyPerson{
    public ProxyPerson(Person p){
        this.p = p;
    }
    private Person p = null;
    public void eat(){
        System.out.println("吃饭前的准备工作");
        p.eat();
    }
}
public class Hello_World{
    public static void main(String[] args){
        Person p = new Person();
        ProxyPerson Proxyp = new ProxyPerson(p);
        Proxyp.eat();
    }
}
```

****

### 工厂设计模式

> **产生背景**
>
> - 在实际的开发场景中,**往往创建一个类是很复杂的**(如创建一个汽车类,可能要涉及到汽车传感器类,轮胎类,车架类,发动机类等等多个类的创建).因此如果每一次当我们的程序需要创建一个汽车时,就会需要涉及到一个非常复杂的创建过程.
> - 工厂设计模式的**开发意义**就在于,其**将汽车类实例化的过程封装到工厂类中**,我们的程序如果需要使用到汽车,就**只需要调用工厂类的方法即可获取到需要的汽车实例**.而**无需去关注汽车实例的构建过程**,因为这个构建过程被我们封装到工厂类中
>
> **作用**
>
> - 实现了**创建者与调用者的分离**,即将创建对象的具体过程屏蔽隔离起来.而由一个特定的结构来对类实例进行创建,然后将创建好的类实例返回出来.而**这个用于创建类实例的特殊结构就被我们称之为`工厂`**
>
> **工厂模式的分类**
>
> - **简单工厂**
>   - 即在一个工厂类中**生产多个不同型号的相同种类**的产品
> - 工厂方法
>   - 即对于一个种类的产品的各个不同型号设计多个不同的工厂类,**每个工厂类只生产一个型号的产品**
> - 抽象工厂

****

## 面向对象设计原则

****

## **`Java`数据类型的转换**

### `Java`基础数据类型的类型`转换`

### `Java`类的`转型`

> **前提**
>
> - 在`Java`中**类之间**的**类型变更**称为`转型`,而**基本数据类型之间**的**类型变更**称为`类型转换`
> - 在`Java`中**只有类与类,基础数据类型与基础数据类型之间**具备**强制以及自动的类型变更**,而**类与基础数据类型**之间的转换则要**通过我们类的方法,构造器等辅助**
> - **`特别的`包装类与其对应的基础数据类型之间是可以自动类型转换的(借助自动装箱与自动拆箱)**
>
> **注意**
>
> - 如果要将类`A`实例**向下转型**为类`B`实例,则**必须**保证类`A`为类`B`的直接或间接父类
> - 如果要将类`A`实例**向上转型**为类`B`实例,则**必须**保证类`B`为类`A`的直接或间接父类
> - 考虑这样的情况,有三个类`A,B,C`,`A为B的父类`,`B为C的父类`.那么我们**有且只有**下面的转换是合法的
>   - 类`A`的指针可以向下转型为`类B,C`的指针,类`B`的指针可以强制向下转型为`类C`的指针
>   - 类`C`的指针可以向上转型为`类A,B`的指针,类`B`的指针可以强制向上转型为`类A`的指针

### `Java`基础数据类型与类的相互类型变更

## `Java`类最好重写的方法

> - `Java`内置的引用数据类型都是重写了`equals`方法和`toString()`方法的
> - **在允许的情况下尽量重写所有的`Object`类中定义了的方法**
>
> **无论是`IDEA`还是`Eclipse`都有自动重写`equals,toString`方法的辅助选项**

- `Object.getClass()`方法是`final`修饰的无法被重写

## `Java`包的导入

- **基本语法**

  ```java
  import java.util.Scanner
  ```

  